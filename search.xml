<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ysyx-B阶段-用RTL实现最简单的处理器-用Chisel实现单周期riscv64处理器[施工中]</title>
      <link href="/2023-04-07-ysyx-B%E9%98%B6%E6%AE%B5-%E7%94%A8RTL%E5%AE%9E%E7%8E%B0%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%A4%84%E7%90%86%E5%99%A8-%E7%94%A8Chisel%E5%AE%9E%E7%8E%B0%E5%8D%95%E5%91%A8%E6%9C%9Friscv64%E5%A4%84%E7%90%86%E5%99%A8/"/>
      <url>/2023-04-07-ysyx-B%E9%98%B6%E6%AE%B5-%E7%94%A8RTL%E5%AE%9E%E7%8E%B0%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%A4%84%E7%90%86%E5%99%A8-%E7%94%A8Chisel%E5%AE%9E%E7%8E%B0%E5%8D%95%E5%91%A8%E6%9C%9Friscv64%E5%A4%84%E7%90%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="ysyx-B阶段-用RTL实现最简单的处理器-用Chisel实现单周期riscv64处理器"><a href="#ysyx-B阶段-用RTL实现最简单的处理器-用Chisel实现单周期riscv64处理器" class="headerlink" title="ysyx-B阶段-用RTL实现最简单的处理器-用Chisel实现单周期riscv64处理器"></a>ysyx-B阶段-用RTL实现最简单的处理器-用Chisel实现单周期riscv64处理器</h1><h2 id="代码仓库及相关网页"><a href="#代码仓库及相关网页" class="headerlink" title="代码仓库及相关网页"></a>代码仓库及相关网页</h2><ul><li><a href="https://ysyx.oscc.cc/">ysyx官方网址</a></li><li><a href="https://nju-projectn.github.io/ics-pa-gitbook/">南京大学计算机系统基础(PA)</a></li><li>为保证<strong>学术诚信</strong>, 此处及接下来将不会给出任何完整代码, 仅提供大致代码思路及问题处理方法</li></ul><h2 id="一生一芯实验报告目录"><a href="#一生一芯实验报告目录" class="headerlink" title="一生一芯实验报告目录"></a>一生一芯实验报告目录</h2><ul><li><a href="https://sin-kider.github.io/2023/03/04/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-Linux-WSL%E5%AE%89%E8%A3%85/">ysyx-预学习阶段-Linux-WSL安装</a></li><li><a href="https://sin-kider.github.io/2023/03/04/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-Linux-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/">ysyx-预学习阶段-Linux-基本使用</a></li><li><a href="https://sin-kider.github.io/2023/03/11/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/">ysyx-预学习阶段-C语言学习</a> </li><li><a href="https://sin-kider.github.io/2023/03/18/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-verilog%E5%AD%A6%E4%B9%A0-%E6%90%AD%E5%BB%BAverilator%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83">ysyx-预学习阶段-verilog学习-搭建verilator仿真环境</a></li><li><a href="https://sin-kider.github.io/2023/03/23/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-PA1-NEMU">ysyx-预学习阶段-PA1-NEMU</a></li><li><a href="https://sin-kider.github.io/2023/03/25/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-%E5%A6%82%E4%BD%95%E7%A7%91%E5%AD%A6%E5%9C%B0%E6%8F%90%E9%97%AE-%E8%AF%BB%E5%90%8E%E6%84%9F">ysyx-预学习阶段-如何科学地提问-读后感</a></li><li><a href="https://sin-kider.github.io/2023/04/01/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-%E6%80%BB%E7%BB%93">ysyx-预学习阶段-总结</a></li><li><a href="https://sin-kider.github.io/2023/04/07/ysyx-B%E9%98%B6%E6%AE%B5-%E7%94%A8RTL%E5%AE%9E%E7%8E%B0%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%A4%84%E7%90%86%E5%99%A8-%E7%94%A8Chisel%E5%AE%9E%E7%8E%B0%E5%8D%95%E5%91%A8%E6%9C%9Friscv64%E5%A4%84%E7%90%86%E5%99%A8">ysyx-B阶段-用RTL实现最简单的处理器-用Chisel实现单周期riscv64处理器</a> ✨</li><li><a href="https://sin-kider.github.io/2023/04/07/ysyx-B%E9%98%B6%E6%AE%B5-%E6%94%AF%E6%8C%81RV64IM%E7%9A%84NEMU-%E7%94%A8NEMU%E8%BF%90%E8%A1%8Criscv64%E7%9A%84%E7%A8%8B%E5%BA%8F">ysyx-B阶段-支持RV64IM的NEMU-用NEMU运行riscv64的程序</a></li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2>]]></content>
      
      
      <categories>
          
          <category> NEMU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ysyx </tag>
            
            <tag> C </tag>
            
            <tag> NEMU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ysyx-B阶段-支持RV64IM的NEMU-用NEMU运行riscv64的程序[施工中]</title>
      <link href="/2023-04-07-ysyx-B%E9%98%B6%E6%AE%B5-%E6%94%AF%E6%8C%81RV64IM%E7%9A%84NEMU-%E7%94%A8NEMU%E8%BF%90%E8%A1%8Criscv64%E7%9A%84%E7%A8%8B%E5%BA%8F/"/>
      <url>/2023-04-07-ysyx-B%E9%98%B6%E6%AE%B5-%E6%94%AF%E6%8C%81RV64IM%E7%9A%84NEMU-%E7%94%A8NEMU%E8%BF%90%E8%A1%8Criscv64%E7%9A%84%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="ysyx-B阶段-支持RV64IM的NEMU-用NEMU运行riscv64的程序"><a href="#ysyx-B阶段-支持RV64IM的NEMU-用NEMU运行riscv64的程序" class="headerlink" title="ysyx-B阶段-支持RV64IM的NEMU-用NEMU运行riscv64的程序"></a>ysyx-B阶段-支持RV64IM的NEMU-用NEMU运行riscv64的程序</h1><h2 id="代码仓库及相关网页"><a href="#代码仓库及相关网页" class="headerlink" title="代码仓库及相关网页"></a>代码仓库及相关网页</h2><ul><li><a href="https://ysyx.oscc.cc/">ysyx官方网址</a></li></ul><h2 id="一生一芯实验报告目录"><a href="#一生一芯实验报告目录" class="headerlink" title="一生一芯实验报告目录"></a>一生一芯实验报告目录</h2><ul><li><a href="https://sin-kider.github.io/2023/03/04/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-Linux-WSL%E5%AE%89%E8%A3%85/">ysyx-预学习阶段-Linux-WSL安装</a></li><li><a href="https://sin-kider.github.io/2023/03/04/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-Linux-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/">ysyx-预学习阶段-Linux-基本使用</a></li><li><a href="https://sin-kider.github.io/2023/03/11/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/">ysyx-预学习阶段-C语言学习</a> </li><li><a href="https://sin-kider.github.io/2023/03/18/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-verilog%E5%AD%A6%E4%B9%A0-%E6%90%AD%E5%BB%BAverilator%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83">ysyx-预学习阶段-verilog学习-搭建verilator仿真环境</a></li><li><a href="https://sin-kider.github.io/2023/03/23/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-PA1-NEMU">ysyx-预学习阶段-PA1-NEMU</a></li><li><a href="https://sin-kider.github.io/2023/03/25/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-%E5%A6%82%E4%BD%95%E7%A7%91%E5%AD%A6%E5%9C%B0%E6%8F%90%E9%97%AE-%E8%AF%BB%E5%90%8E%E6%84%9F">ysyx-预学习阶段-如何科学地提问-读后感</a></li><li><a href="https://sin-kider.github.io/2023/04/01/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-%E6%80%BB%E7%BB%93">ysyx-预学习阶段-总结</a></li><li><a href="https://sin-kider.github.io/2023/04/07/ysyx-B%E9%98%B6%E6%AE%B5-%E7%94%A8RTL%E5%AE%9E%E7%8E%B0%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%A4%84%E7%90%86%E5%99%A8-%E7%94%A8Chisel%E5%AE%9E%E7%8E%B0%E5%8D%95%E5%91%A8%E6%9C%9Friscv64%E5%A4%84%E7%90%86%E5%99%A8">ysyx-B阶段-用RTL实现最简单的处理器-用Chisel实现单周期riscv64处理器</a></li><li><a href="https://sin-kider.github.io/2023/04/07/ysyx-B%E9%98%B6%E6%AE%B5-%E6%94%AF%E6%8C%81RV64IM%E7%9A%84NEMU-%E7%94%A8NEMU%E8%BF%90%E8%A1%8Criscv64%E7%9A%84%E7%A8%8B%E5%BA%8F">ysyx-B阶段-支持RV64IM的NEMU-用NEMU运行riscv64的程序</a> ✨</li></ul><h2 id="实现NEMU运行riscv64的程序"><a href="#实现NEMU运行riscv64的程序" class="headerlink" title="实现NEMU运行riscv64的程序"></a>实现NEMU运行riscv64的程序</h2><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><p>作为一颗优秀的CPU, 你应该完成以下几个行为:</p><ul><li>取指(IF)<ul><li>将PC指向的指令从存储器中取出</li><li>在NEMU中函数<code>inst_fetch()</code>运行时会将下一条指令传入<code>s-&gt;snpc</code>中</li></ul></li><li>译码(ID)<ul><li>识别区分出指令的类型或功能</li><li>在NEMU中的<code>decode_exec()</code>会将<code>s-&gt;snpc</code>或<code>s-&gt;dnpc</code>的指令解析</li><li>解析规则在<code>inst.c</code>中实现</li></ul></li><li>执行(EX)<ul><li>完成指令对应的操作</li><li>执行同样是在<code>inst.c</code>中实现</li></ul></li><li>访存(MEM)&#x2F;回写(WB)<ul><li>在NEMU中这两个操作与上一步执行几乎是同时进行的, 所以在这不做说明</li><li>在单周期RTL中会对这两个操作重新说明</li></ul></li><li>更新PC<ul><li>NEMU文档中将这一步单独列为一个操作</li><li>本质就是将PC自增4或者让PC等于下一条动态指令</li></ul></li></ul><h3 id="开始实现"><a href="#开始实现" class="headerlink" title="开始实现"></a>开始实现</h3><p>按照PA文档操作, 使用<code>make ARCH=$ISA-nemu ALL=dummy run</code>运行测试文件<code>dummy</code>, 一定会在某一个指令报错. 因为还没有开始实现任何指令.<br>RTFSC可知, 首先需要在<code>inst.c</code>中完成对不同指令类型的不同解析方式, 共6种: <code>I</code>, <code>U</code>, <code>S</code>, <code>R</code>, <code>J</code>, <code>B</code>.<br>实际上很简单, 在<code>enum</code>中添加其他类型, 然后将指令立即数解析的宏定义完成, 最后在<code>decode_operand()</code>函数中进行匹配就行.<br>下面给出大致实现方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">  TYPE_I, TYPE_U, TYPE_?,</span><br><span class="line">  TYPE_?, TYPE_?, TYPE_?, <span class="comment">// 添加缺少的类型</span></span><br><span class="line">  TYPE_N, <span class="comment">// none</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> src1R() do &#123; *src1 = R(rs1); &#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> src2R() do &#123; *src2 = R(rs2); &#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> immI() do &#123; *imm = SEXT(BITS(i, 31, 20), 12); &#125; while(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> immU() do &#123; *imm = SEXT(BITS(i, 31, 12), 20) &lt;&lt; 12; &#125; while(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> imm?() do &#123; *imm = ...; &#125; while(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> imm?() do &#123; *imm = ...; &#125; while(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> imm?() do &#123; *imm = ...; &#125; while(0)</span></span><br><span class="line"><span class="comment">// 有一种类型没有立即数, 可以省略立即数解析这一步</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">decode_operand</span><span class="params">(Decode *s, <span class="type">int</span> *rd, <span class="type">word_t</span> *src1, <span class="type">word_t</span> *src2, <span class="type">word_t</span> *imm, <span class="type">int</span> type)</span> &#123;</span><br><span class="line">  <span class="type">uint32_t</span> i = s-&gt;isa.inst.val;</span><br><span class="line">  <span class="type">int</span> rs1 = BITS(i, <span class="number">19</span>, <span class="number">15</span>);</span><br><span class="line">  <span class="type">int</span> rs2 = BITS(i, <span class="number">24</span>, <span class="number">20</span>);</span><br><span class="line">  *rd     = BITS(i, <span class="number">11</span>, <span class="number">7</span>);</span><br><span class="line">  <span class="keyword">switch</span> (type) &#123; <span class="comment">// 对照riscv手册完成指令解析匹配</span></span><br><span class="line">    <span class="keyword">case</span> TYPE_I: src1R();          immI(); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TYPE_U:                   immU(); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TYPE_?: ...     ...       ...   ; <span class="keyword">break</span>; </span><br><span class="line">    <span class="keyword">case</span> TYPE_?: ...     ...       ...   ; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TYPE_?: ...     ...       ...   ; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TYPE_?: ...     ...       ...   ; <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">INSTPAT_START();</span><br><span class="line">INSTPAT(<span class="string">&quot;??????? ????? ????? ??? ????? ????? ??&quot;</span>, xxx    , N, ...);</span><br><span class="line"><span class="comment">//  问号代表在该位匹配任意数值, 1或0则为匹配对应数值, xxx为指令名, N为指令类型,必须与前面的TYPE_?对应, 最后则是对应的操作, 可以写多条c的语句</span></span><br><span class="line">INSTPAT_END();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Chisel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ysyx </tag>
            
            <tag> Chisel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ysyx-预学习阶段-总结</title>
      <link href="/2023-04-01-ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-%E6%80%BB%E7%BB%93/"/>
      <url>/2023-04-01-ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="ysyx-预学习阶段-总结"><a href="#ysyx-预学习阶段-总结" class="headerlink" title="ysyx-预学习阶段-总结"></a>ysyx-预学习阶段-总结</h1><h2 id="代码仓库及相关网页"><a href="#代码仓库及相关网页" class="headerlink" title="代码仓库及相关网页"></a>代码仓库及相关网页</h2><ul><li><a href="https://ysyx.oscc.cc/">ysyx官方网址</a></li></ul><h2 id="一生一芯实验报告目录"><a href="#一生一芯实验报告目录" class="headerlink" title="一生一芯实验报告目录"></a>一生一芯实验报告目录</h2><ul><li><a href="https://sin-kider.github.io/2023/03/04/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-Linux-WSL%E5%AE%89%E8%A3%85/">ysyx-预学习阶段-Linux-WSL安装</a></li><li><a href="https://sin-kider.github.io/2023/03/04/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-Linux-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/">ysyx-预学习阶段-Linux-基本使用</a></li><li><a href="https://sin-kider.github.io/2023/03/11/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/">ysyx-预学习阶段-C语言学习</a> </li><li><a href="https://sin-kider.github.io/2023/03/18/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-verilog%E5%AD%A6%E4%B9%A0-%E6%90%AD%E5%BB%BAverilator%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83">ysyx-预学习阶段-verilog学习-搭建verilator仿真环境</a></li><li><a href="https://sin-kider.github.io/2023/03/23/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-PA1-NEMU">ysyx-预学习阶段-PA1-NEMU</a></li><li><a href="https://sin-kider.github.io/2023/03/25/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-%E5%A6%82%E4%BD%95%E7%A7%91%E5%AD%A6%E5%9C%B0%E6%8F%90%E9%97%AE-%E8%AF%BB%E5%90%8E%E6%84%9F">ysyx-预学习阶段-如何科学地提问-读后感</a></li><li><a href="https://sin-kider.github.io/2023/04/01/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-%E6%80%BB%E7%BB%93">ysyx-预学习阶段-总结</a> ✨</li><li><a href="https://sin-kider.github.io/2023/04/07/ysyx-B%E9%98%B6%E6%AE%B5-%E7%94%A8RTL%E5%AE%9E%E7%8E%B0%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%A4%84%E7%90%86%E5%99%A8-%E7%94%A8Chisel%E5%AE%9E%E7%8E%B0%E5%8D%95%E5%91%A8%E6%9C%9Friscv64%E5%A4%84%E7%90%86%E5%99%A8">ysyx-B阶段-用RTL实现最简单的处理器-用Chisel实现单周期riscv64处理器</a></li><li><a href="https://sin-kider.github.io/2023/04/07/ysyx-B%E9%98%B6%E6%AE%B5-%E6%94%AF%E6%8C%81RV64IM%E7%9A%84NEMU-%E7%94%A8NEMU%E8%BF%90%E8%A1%8Criscv64%E7%9A%84%E7%A8%8B%E5%BA%8F">ysyx-B阶段-支持RV64IM的NEMU-用NEMU运行riscv64的程序</a></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="所学到的内容"><a href="#所学到的内容" class="headerlink" title="所学到的内容"></a>所学到的内容</h3><p>如果单说学到了多少内容, 那不列张表格的话是说不完的, 预学习这段过程带给我的成长无疑是巨大的. 仅仅只是<code>PA0</code>就让我从对linux一窍不通到基本掌握使用方法. 更不用说曾经及其依赖各式各样的IDE, 现在有个vim就能开发大部分项目. 包括make, git等工具, 曾经我觉得纯属旧时代遗物的东西, 现在我才知道他们的强大, 方便的脚本工具, 强大的代码管理等等.<br>具体来说, 预学习阶段大致分为四个大块:</p><ul><li>Linux</li><li>C</li><li>verilog</li><li>PA1</li></ul><p>Linux习题让我摆脱了对各类linux桌面的依赖, 转向纯命令行的WSL. 我还为自己的linux编写各种脚本为了方便使用, 在这之前我只能通过linux桌面提供的设置程序来进行. 就在这时我学会了不只是linux的操作, 还有独立解决问题的能力(STFW).<br>C语言的习题本来打算跳过的, 因为我当时觉得C语言这么简单, 没必要. 但是离开了IDE我发现我一窍不通, 勉强学会gcc后编译起来也麻烦, 更不用说gdb调试了. 回头再去看给出的习题与资料才发现, 原来真实的开发方法是这样的.<br>verilog习题本身并没有难到我, 但是verilator的使用与nvboard如何接入项目让我头疼了一段时间, 后来尝试RTFSC才将问题解决.<br>PA1就有点像是前面几个的综合考察了, 考验如何读文档和手册, 如何阅读他人源码, 如何测试程序, 一个程序该如何编写, 功能实现与功能测试的重要性等等等等.<br>总之, STFW, RTFSC, RTFM这三个方法覆盖了整个预学习阶段, 没了这些我不可能做完. 这一个月以来的学习, 我的收获可以说比我从进入大学到现在学习到的东西还要多. 接下来我还是会继续学习B阶段, 甚至A阶段, 看看能不能有机会得到流片的资格.</p>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ysyx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ysyx-预学习阶段-如何科学地提问-读后感</title>
      <link href="/2023-03-25-ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-%E5%A6%82%E4%BD%95%E7%A7%91%E5%AD%A6%E5%9C%B0%E6%8F%90%E9%97%AE-%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
      <url>/2023-03-25-ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-%E5%A6%82%E4%BD%95%E7%A7%91%E5%AD%A6%E5%9C%B0%E6%8F%90%E9%97%AE-%E8%AF%BB%E5%90%8E%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="ysyx-预学习阶段-如何科学地提问-读后感"><a href="#ysyx-预学习阶段-如何科学地提问-读后感" class="headerlink" title="ysyx-预学习阶段-如何科学地提问-读后感"></a>ysyx-预学习阶段-如何科学地提问-读后感</h1><h2 id="代码仓库及相关网页"><a href="#代码仓库及相关网页" class="headerlink" title="代码仓库及相关网页"></a>代码仓库及相关网页</h2><ul><li><a href="https://ysyx.oscc.cc/">ysyx官方网址</a></li><li><a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md">提问的智慧</a></li><li><a href="https://github.com/tangx/Stop-Ask-Questions-The-Stupid-Ways/blob/master/README.md">别像弱智一样提问</a></li></ul><h2 id="一生一芯实验报告目录"><a href="#一生一芯实验报告目录" class="headerlink" title="一生一芯实验报告目录"></a>一生一芯实验报告目录</h2><ul><li><a href="https://sin-kider.github.io/2023/03/04/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-Linux-WSL%E5%AE%89%E8%A3%85/">ysyx-预学习阶段-Linux-WSL安装</a></li><li><a href="https://sin-kider.github.io/2023/03/04/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-Linux-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/">ysyx-预学习阶段-Linux-基本使用</a></li><li><a href="https://sin-kider.github.io/2023/03/11/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/">ysyx-预学习阶段-C语言学习</a> </li><li><a href="https://sin-kider.github.io/2023/03/18/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-verilog%E5%AD%A6%E4%B9%A0-%E6%90%AD%E5%BB%BAverilator%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83">ysyx-预学习阶段-verilog学习-搭建verilator仿真环境</a></li><li><a href="https://sin-kider.github.io/2023/03/23/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-PA1-NEMU">ysyx-预学习阶段-PA1-NEMU</a></li><li><a href="https://sin-kider.github.io/2023/03/25/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-%E5%A6%82%E4%BD%95%E7%A7%91%E5%AD%A6%E5%9C%B0%E6%8F%90%E9%97%AE-%E8%AF%BB%E5%90%8E%E6%84%9F">ysyx-预学习阶段-如何科学地提问-读后感</a> ✨</li><li><a href="https://sin-kider.github.io/2023/04/01/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-%E6%80%BB%E7%BB%93">ysyx-预学习阶段-总结</a></li><li><a href="https://sin-kider.github.io/2023/04/07/ysyx-B%E9%98%B6%E6%AE%B5-%E7%94%A8RTL%E5%AE%9E%E7%8E%B0%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%A4%84%E7%90%86%E5%99%A8-%E7%94%A8Chisel%E5%AE%9E%E7%8E%B0%E5%8D%95%E5%91%A8%E6%9C%9Friscv64%E5%A4%84%E7%90%86%E5%99%A8">ysyx-B阶段-用RTL实现最简单的处理器-用Chisel实现单周期riscv64处理器</a></li><li><a href="https://sin-kider.github.io/2023/04/07/ysyx-B%E9%98%B6%E6%AE%B5-%E6%94%AF%E6%8C%81RV64IM%E7%9A%84NEMU-%E7%94%A8NEMU%E8%BF%90%E8%A1%8Criscv64%E7%9A%84%E7%A8%8B%E5%BA%8F">ysyx-B阶段-支持RV64IM的NEMU-用NEMU运行riscv64的程序</a></li></ul><h2 id="个人感想"><a href="#个人感想" class="headerlink" title="个人感想"></a>个人感想</h2><p>说实话我个人很早之前就看过类似的文章与梗图, 当时都是当一个<a href="/img/post_img/img_001.jpg">表情包</a>收藏以备碰到一些不带脑子问问题的人. 我自己就很讨厌上来提问就几个字, 完全不管问题表述是否清晰的人. 但是到我自己来提问的时候又发现把问题说明白并不简单.<br>在阅读完两篇文章后,我大致对问问题有了一定的理解. <a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md">提问的智慧</a>将问问题大致分成了三个步骤:</p><ul><li>在提问之前  </li><li>当你提问时  </li><li>如何解读答案</li></ul><p>我个人在读完整篇文章后对其的解读是:</p><ol><li>提问之前需要判断自己的问题是否是”<strong>新</strong>“的. 现在的网络这么发达, 基本上所有问题都能通过其他方式找到解决方法. 搜索引擎, 相关论坛, 官方手册, 官方例程, 官方代码, 常见问题(FAQ)等很多时候都能找到需要的资料. 灵活运用这些搜索方式, 基本上能直接在询问问题之前就将问题解决. </li><li>提问时尽可能让问题表述清晰, 完整, 精准, 让回答者更容易回复. 保证问题阅读者能够轻松的明确问题内容, 几乎是提问者所必须具备的. 描述时需要明确一些问题: 选择提问的平台, 标题是否明确且有意义, 是否描述清楚问题症状, 所选平台是否方便回答者回复, 问题排版是否易读, 提问时是否有礼等. 解决上述问题, 那么基本上都能得到他人友好且有用的回复.  </li><li>如果被回复<code>STFW</code>和<code>RTFM</code>, 证明这两个方法足够解决你的问题, 问题本身并不是”<strong>新</strong>“的. 在得到有效回复时, 需要自行理解对方的回应, <code>STFW</code>和<code>RTFM</code>还是不可或缺的一部分. 最终解决问题的时候需要加个简短的补充说明, 让其他人知晓你的问题是如何解决的, 给予其他人一些参考.</li></ol><p>说回我个人, 由于一些原因, 我更多时候是充当回复者这一角色, 整个预学习阶段我并没有问多少问题, 并不是因为我啥都会, 而是我碰到的问题在网上全都有解决方法. 就算直接搜索问题不能解决, 通过查看官网&#x2F;手册&#x2F;源码也能将预学习阶段的问题解决. 我自己稍微有些内向, 所以比较倾向于自己解决, 问问题的时候真的很少<del>除非网上搜索也算问问题</del>. 上一次在公开平台询问问题还是在<code>vscode</code>的插件<code>eide</code>开发者提供的论坛上询问插件更新后的一些兼容性问题: <a href="/img/post_img/img_002.png">当时的截图</a><del>问的应该还行</del>. 总的来说, 读完整两篇对我来说也确实有一些感想, 以前在询问&#x2F;回答问题时我都没有想到这么多, 观看时我也回想了一下自己的做法. 以后我将尝试将文章中的一些观点与方法融合进自己的思想, 学习正确的询问.</p>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ysyx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ysyx-预学习阶段-PA1-NEMU</title>
      <link href="/2023-03-23-ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-PA1-NEMU/"/>
      <url>/2023-03-23-ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-PA1-NEMU/</url>
      
        <content type="html"><![CDATA[<h1 id="ysyx-预学习阶段-PA1-NEMU"><a href="#ysyx-预学习阶段-PA1-NEMU" class="headerlink" title="ysyx-预学习阶段-PA1-NEMU"></a>ysyx-预学习阶段-PA1-NEMU</h1><h2 id="代码仓库及相关网页"><a href="#代码仓库及相关网页" class="headerlink" title="代码仓库及相关网页"></a>代码仓库及相关网页</h2><ul><li><a href="https://ysyx.oscc.cc/">ysyx官方网址</a></li><li><a href="https://nju-projectn.github.io/ics-pa-gitbook/">南京大学计算机系统基础(PA)</a></li><li>为保证<strong>学术诚信</strong>, 此处及接下来将不会给出任何完整代码, 仅提供大致代码思路及问题处理方法</li></ul><h2 id="一生一芯实验报告目录"><a href="#一生一芯实验报告目录" class="headerlink" title="一生一芯实验报告目录"></a>一生一芯实验报告目录</h2><ul><li><a href="https://sin-kider.github.io/2023/03/04/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-Linux-WSL%E5%AE%89%E8%A3%85/">ysyx-预学习阶段-Linux-WSL安装</a></li><li><a href="https://sin-kider.github.io/2023/03/04/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-Linux-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/">ysyx-预学习阶段-Linux-基本使用</a></li><li><a href="https://sin-kider.github.io/2023/03/11/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/">ysyx-预学习阶段-C语言学习</a> </li><li><a href="https://sin-kider.github.io/2023/03/18/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-verilog%E5%AD%A6%E4%B9%A0-%E6%90%AD%E5%BB%BAverilator%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83">ysyx-预学习阶段-verilog学习-搭建verilator仿真环境</a></li><li><a href="https://sin-kider.github.io/2023/03/23/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-PA1-NEMU">ysyx-预学习阶段-PA1-NEMU</a> ✨</li><li><a href="https://sin-kider.github.io/2023/03/25/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-%E5%A6%82%E4%BD%95%E7%A7%91%E5%AD%A6%E5%9C%B0%E6%8F%90%E9%97%AE-%E8%AF%BB%E5%90%8E%E6%84%9F">ysyx-预学习阶段-如何科学地提问-读后感</a></li><li><a href="https://sin-kider.github.io/2023/04/01/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-%E6%80%BB%E7%BB%93">ysyx-预学习阶段-总结</a></li><li><a href="https://sin-kider.github.io/2023/04/07/ysyx-B%E9%98%B6%E6%AE%B5-%E7%94%A8RTL%E5%AE%9E%E7%8E%B0%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%A4%84%E7%90%86%E5%99%A8-%E7%94%A8Chisel%E5%AE%9E%E7%8E%B0%E5%8D%95%E5%91%A8%E6%9C%9Friscv64%E5%A4%84%E7%90%86%E5%99%A8">ysyx-B阶段-用RTL实现最简单的处理器-用Chisel实现单周期riscv64处理器</a></li><li><a href="https://sin-kider.github.io/2023/04/07/ysyx-B%E9%98%B6%E6%AE%B5-%E6%94%AF%E6%8C%81RV64IM%E7%9A%84NEMU-%E7%94%A8NEMU%E8%BF%90%E8%A1%8Criscv64%E7%9A%84%E7%A8%8B%E5%BA%8F">ysyx-B阶段-支持RV64IM的NEMU-用NEMU运行riscv64的程序</a></li></ul><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="NEMU是什么"><a href="#NEMU是什么" class="headerlink" title="NEMU是什么?"></a>NEMU是什么?</h3><p>NEMU实际上就是一套模拟硬件系统的程序, 使其他程序能够在NEMU模拟的硬件上运行.</p><h3 id="计算机可以没有寄存器吗"><a href="#计算机可以没有寄存器吗" class="headerlink" title="计算机可以没有寄存器吗?"></a>计算机可以没有寄存器吗?</h3><p>我认为是可行的, 可以使用内存代替cpu内的寄存器. 不过速度会慢很多.</p><h3 id="尝试理解计算机如何计算"><a href="#尝试理解计算机如何计算" class="headerlink" title="尝试理解计算机如何计算"></a>尝试理解计算机如何计算</h3><p>例如, 下面的指令序列可以计算<code>1+2+...+100</code>, 其中<code>r1</code>和<code>r2</code>是两个寄存器, 还有一个隐含的程序计数器<code>PC</code>, 它的初值是<code>0</code>.</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// PC: instruction    | // label: statement</span><br><span class="line">0: mov  r1, 0         |  pc0: r1 = 0;</span><br><span class="line">1: mov  r2, 0         |  pc1: r2 = 0;</span><br><span class="line">2: addi r2, r2, 1     |  pc2: r2 = r2 + 1;</span><br><span class="line">3: add  r1, r1, r2    |  pc3: r1 = r1 + r2;</span><br><span class="line">4: blt  r2, 100, 2    |  pc4: if (r2 &lt; 100) goto pc2;   // branch if less than</span><br><span class="line">5: jmp 5              |  pc5: goto pc5;</span><br></pre></td></tr></table></figure><p>基本流程: </p><ul><li><code>PC</code>初值为<code>0</code>, 取出地址<code>0</code>内的命令<code>mov  r1, 0</code>执行后<code>r1</code>寄存器储存数值为<code>0</code>, 然后<code>PC</code>更新, 值为<code>1</code></li><li><code>PC</code>值为<code>1</code>, 取出地址<code>1</code>内的命令<code>mov  r2, 0</code>执行后<code>r2</code>寄存器储存数值为<code>0</code>, 然后<code>PC</code>更新, 值为<code>2</code></li><li><code>PC</code>值为<code>2</code>, 取出地址<code>2</code>内的命令<code>addi r2, r2, 1</code>执行后<code>r2</code>寄存器储存数值为当前<code>r2</code>值加<code>1</code>, 然后<code>PC</code>更新, 值为<code>3</code></li><li><code>PC</code>值为<code>3</code>, 取出地址<code>3</code>内的命令<code>add  r1, r1, r2</code>执行后<code>r1</code>寄存器储存数值为当前<code>r1</code>值加<code>r2</code>值, 然后<code>PC</code>更新, 值为<code>4</code></li><li><code>PC</code>值为<code>4</code>, 取出地址<code>4</code>内的命令<code>blt  r2, 100, 2</code>执行后若<code>r2</code>小于<code>100</code>, <code>PC</code>更新, 值为<code>2</code></li><li><code>PC</code>值为<code>5</code>, 取出地址<code>5</code>内的命令<code>jmp 5</code>执行后, <code>PC</code>更新, 值为<code>5</code></li></ul><h3 id="为什么-init-monitor-全部都是函数"><a href="#为什么-init-monitor-全部都是函数" class="headerlink" title="为什么 init_monitor() 全部都是函数?"></a>为什么 init_monitor() 全部都是函数?</h3><p>将复杂或重复的功能进行分段封装, 有利于理清思路与后期维护</p><h3 id="int-argc-char-argv-是从哪里来的呢"><a href="#int-argc-char-argv-是从哪里来的呢" class="headerlink" title="int argc, char *argv[]是从哪里来的呢?"></a><code>int argc, char *argv[]</code>是从哪里来的呢?</h3><p>STFW后发现这两个参数为操作系统提供的, 用于命令行参数获取</p><h3 id="解决运行NEMU报错"><a href="#解决运行NEMU报错" class="headerlink" title="解决运行NEMU报错"></a>解决运行NEMU报错</h3><p>根据报错信息分析, 在<code>src/monitor/monitor.c:21</code>处发生了<code>assert</code>, 删除对应代码后运行正常</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[src/monitor/monitor.c:20 welcome] Exercise: Please remove me in the source code and compile NEMU again.</span><br><span class="line">riscv32-nemu-interpreter: src/monitor/monitor.c:21: welcome: Assertion `0&#x27; failed.</span><br></pre></td></tr></table></figure><h3 id="在cmd-c-函数中-调用cpu-exec-的时候传入了参数-1-你知道这是什么意思吗"><a href="#在cmd-c-函数中-调用cpu-exec-的时候传入了参数-1-你知道这是什么意思吗" class="headerlink" title="在cmd_c()函数中, 调用cpu_exec()的时候传入了参数-1, 你知道这是什么意思吗?"></a>在<code>cmd_c()</code>函数中, 调用<code>cpu_exec()</code>的时候传入了参数<code>-1</code>, 你知道这是什么意思吗?</h3><p>本来以为特意定义了输入<code>-1</code>时持续运行, <code>RTFSC</code>后发现只是利用负数赋值给<code>unsigned</code>类型变量会变成该类型最大值, 变相的一直运行<del>我怎么没想过这样玩</del></p><h3 id="“调用cpu-exec-的时候传入了参数-1“-这一做法属于未定义行为吗-请查阅C99手册确认你的想法"><a href="#“调用cpu-exec-的时候传入了参数-1“-这一做法属于未定义行为吗-请查阅C99手册确认你的想法" class="headerlink" title="“调用cpu_exec()的时候传入了参数-1“, 这一做法属于未定义行为吗? 请查阅C99手册确认你的想法."></a>“调用<code>cpu_exec()</code>的时候传入了参数<code>-1</code>“, 这一做法属于未定义行为吗? 请查阅C99手册确认你的想法.</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In practice many portable C programs assume that signed integer overflow wraps around reliably using two’s complement arithmetic. Yet the C standard says that program behavior is undefined on overflow, and in a few cases C programs do not work on some modern implementations because their overflows do not wrap around as their authors expected. Conversely, in signed integer remainder, the C standard requires overflow behavior that is commonly not implemented.</span><br></pre></td></tr></table></figure><p>RTFM的结果是, 有符号溢出是未定义的, 但是无符号不是  </p><h3 id="谁来指示程序的结束"><a href="#谁来指示程序的结束" class="headerlink" title="谁来指示程序的结束?"></a>谁来指示程序的结束?</h3><p>STFW发现在<code>main</code>函数前后都有其他命令在运行, 例如<code>atexit</code>函数可使函数在<code>main</code>函数后运行</p><h3 id="优美地退出"><a href="#优美地退出" class="headerlink" title="优美地退出"></a>优美地退出</h3><p><del>还是RTFSC, 将<code>nemu_state.state</code>赋值<code>NEMU_QUIT</code>后可正常退出</del><br>后续做完回头发现不对, 需要判断<code>nemu_state.halt_ret</code>的值后, 再选择赋值</p><h3 id="简易调试器"><a href="#简易调试器" class="headerlink" title="简易调试器"></a>简易调试器</h3><ol><li>单步执行<ul><li>函数<code>void cpu_exec(uint64_t n)</code>可以执行<code>n</code>步</li></ul></li><li>打印寄存器<ul><li>宏定义<code>#define gpr(idx) (cpu.gpr[check_reg_idx(idx)])</code>可返回对应寄存器的值</li></ul></li><li>扫描内存<ul><li>函数<code>word_t vaddr_read(vaddr_t addr, int len)</code>有相关实现</li></ul></li><li>表达式求值</li></ol><ul><li>下面给出个人的思路: <ul><li>表达式共分为几种类型: 可解析类型<code>十进制数字&#39;123&#39;</code>, <code>十六进制数字&#39;0xAF&#39;</code>, <code>寄存器&#39;$t0&#39;</code>; 普通运算符<code>加&#39;+&#39;</code>, <code>减-</code>, <code>乘&#39;*&#39;</code>, <code>除&#39;/&#39;</code>, <code>左移&#39;&lt;&lt;&#39;</code>, <code>相等&#39;==&#39;</code>等; 特殊运算符<code>解引用&#39;*&#39;</code>, <code>负号&#39;-&#39;</code>; 括号: <code>前括号&#39;(&#39;</code>, <code>后括号&#39;)&#39;</code>;</li><li>识别元素时仅识别可解析类型, 普通运算符和括号. 特殊运算符并不是指功能特殊, 而是<strong>符号</strong>特殊. 比如负号与减号相同, 但是一个是单目运算, 一个是双目运算. 在识别成功”<code>-</code>“号时, 单独判断是否为单目运算符, 再给其赋予类型</li><li>所有运算符有对应优先级, 对应优先级我参考了C语言手册</li><li>表达式递归计算需要对表达式进行分割, 对表达式进行遍历, 找出没被括号包裹的优先级最低的运算符处进行分割</li><li>若当前表达式被前后对应的括号包裹, 就将括号解开</li></ul></li><li>下面给出代码框架<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">expression_value</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">    出错, 退出;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> cut_addr = 分割点;</span><br><span class="line">  <span class="keyword">if</span> (start与end正好为前后对应的括号) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">expression_value</span>(start + <span class="number">1</span>, end - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">    <span class="keyword">if</span> (是十进制数字) &#123;</span><br><span class="line">      <span class="keyword">return</span> 数字的值;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (是十六进制数字) &#123;</span><br><span class="line">      <span class="keyword">return</span> ...;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (是寄存器) &#123;</span><br><span class="line">      <span class="keyword">return</span> ...;</span><br><span class="line">    &#125;</span><br><span class="line">    错误, 退出;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (判断切割点type[cut_addr]的类型) &#123;</span><br><span class="line">      <span class="keyword">case</span> 加号: <span class="keyword">return</span> <span class="built_in">expression_value</span>(start, cut_add - <span class="number">1</span>) + <span class="built_in">expression_value</span>(cut_add + <span class="number">1</span>, end); <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> 减号: <span class="keyword">return</span> <span class="built_in">expression_value</span>(start, cut_add - <span class="number">1</span>) - <span class="built_in">expression_value</span>(cut_add + <span class="number">1</span>, end); <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> ...;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="监视点"><a href="#监视点" class="headerlink" title="监视点"></a>监视点</h3><p>监视点实现比较简单, 主要是操作链表, 这里就不展示了<br>监视点自动停止运行只需要在<code>static void trace_and_difftest(Decode *_this, vaddr_t dnpc)</code>函数中添加</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">is_change</span>()) &#123;</span><br><span class="line">  nemu_state.state = NEMU_STOP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> NEMU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ysyx </tag>
            
            <tag> Linux </tag>
            
            <tag> C </tag>
            
            <tag> NEMU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ysyx-预学习阶段-verilog学习-搭建verilator仿真环境</title>
      <link href="/2023-03-18-ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-verilog%E5%AD%A6%E4%B9%A0-%E6%90%AD%E5%BB%BAverilator%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83/"/>
      <url>/2023-03-18-ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-verilog%E5%AD%A6%E4%B9%A0-%E6%90%AD%E5%BB%BAverilator%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h1 id="ysyx-预学习阶段-verilog学习-搭建verilator仿真环境"><a href="#ysyx-预学习阶段-verilog学习-搭建verilator仿真环境" class="headerlink" title="ysyx-预学习阶段-verilog学习-搭建verilator仿真环境"></a>ysyx-预学习阶段-verilog学习-搭建verilator仿真环境</h1><h2 id="代码仓库及相关网页"><a href="#代码仓库及相关网页" class="headerlink" title="代码仓库及相关网页"></a>代码仓库及相关网页</h2><ul><li><a href="https://ysyx.oscc.cc/">ysyx官方网址</a></li><li><a href="https://github.com/NJU-ProjectN/nvboard">NJU-ProjectN&#x2F;nvboard</a></li><li><a href="https://nju-projectn.github.io/dlco-lecture-note/index.html">数字电路与计算机组成实验</a></li><li><a href="https://gitee.com/sin-kider/verilog_learn">Sin_kider&#x2F;verilog_learn</a></li></ul><h2 id="一生一芯实验报告目录"><a href="#一生一芯实验报告目录" class="headerlink" title="一生一芯实验报告目录"></a>一生一芯实验报告目录</h2><ul><li><a href="https://sin-kider.github.io/2023/03/04/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-Linux-WSL%E5%AE%89%E8%A3%85/">ysyx-预学习阶段-Linux-WSL安装</a></li><li><a href="https://sin-kider.github.io/2023/03/04/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-Linux-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/">ysyx-预学习阶段-Linux-基本使用</a></li><li><a href="https://sin-kider.github.io/2023/03/11/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/">ysyx-预学习阶段-C语言学习</a> </li><li><a href="https://sin-kider.github.io/2023/03/18/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-verilog%E5%AD%A6%E4%B9%A0-%E6%90%AD%E5%BB%BAverilator%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83">ysyx-预学习阶段-verilog学习-搭建verilator仿真环境</a> ✨</li><li><a href="https://sin-kider.github.io/2023/03/23/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-PA1-NEMU">ysyx-预学习阶段-PA1-NEMU</a></li><li><a href="https://sin-kider.github.io/2023/03/25/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-%E5%A6%82%E4%BD%95%E7%A7%91%E5%AD%A6%E5%9C%B0%E6%8F%90%E9%97%AE-%E8%AF%BB%E5%90%8E%E6%84%9F">ysyx-预学习阶段-如何科学地提问-读后感</a></li><li><a href="https://sin-kider.github.io/2023/04/01/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-%E6%80%BB%E7%BB%93">ysyx-预学习阶段-总结</a></li><li><a href="https://sin-kider.github.io/2023/04/07/ysyx-B%E9%98%B6%E6%AE%B5-%E7%94%A8RTL%E5%AE%9E%E7%8E%B0%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%A4%84%E7%90%86%E5%99%A8-%E7%94%A8Chisel%E5%AE%9E%E7%8E%B0%E5%8D%95%E5%91%A8%E6%9C%9Friscv64%E5%A4%84%E7%90%86%E5%99%A8">ysyx-B阶段-用RTL实现最简单的处理器-用Chisel实现单周期riscv64处理器</a></li><li><a href="https://sin-kider.github.io/2023/04/07/ysyx-B%E9%98%B6%E6%AE%B5-%E6%94%AF%E6%8C%81RV64IM%E7%9A%84NEMU-%E7%94%A8NEMU%E8%BF%90%E8%A1%8Criscv64%E7%9A%84%E7%A8%8B%E5%BA%8F">ysyx-B阶段-支持RV64IM的NEMU-用NEMU运行riscv64的程序</a></li></ul><h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><p><code>verilator</code>安装还是比较简单的, 只需要跟随<a href="https://verilator.org/guide/latest/install.html">官方手册</a>走就行, 以下是安装<code>5.008</code>版本的方法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git perl python3 make autoconf g++ flex bison ccache</span><br><span class="line">sudo apt-get install libgoogle-perftools-dev numactl perl-doc</span><br><span class="line">sudo apt-get install libfl2  # 报错就忽略</span><br><span class="line">sudo apt-get install libfl-dev  # 报错就忽略</span><br><span class="line">sudo apt-get install zlibc zlib1g zlib1g-dev  # 报错就忽略</span><br><span class="line"></span><br><span class="line">git clone https://github.com/verilator/verilator   # 克隆项目</span><br><span class="line"></span><br><span class="line">cd verilator </span><br><span class="line"></span><br><span class="line">git checkout v5.008  # 切换到对应分支</span><br><span class="line"></span><br><span class="line">autoconf</span><br><span class="line">./configure</span><br><span class="line">make -j `你的cpu核心数`</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>如果安装时遇到报错<code>make: help2man: No such file or directory</code>, 就手动安装一下<code>help2man</code>  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install help2man</span><br></pre></td></tr></table></figure><p><code>verilator</code>项目结构与部分文件如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">├── Makefile</span><br><span class="line">├── build</span><br><span class="line">│   ├── bin     // 程序与生成的波形文件</span><br><span class="line">│   └── temp    // 中间文件</span><br><span class="line">├── csrc</span><br><span class="line">│   ├── INC</span><br><span class="line">│   |   └── main.h</span><br><span class="line">│   └── SRC</span><br><span class="line">│       └── main.cpp</span><br><span class="line">└── vsrc</span><br><span class="line">    └── top.v</span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ./Makefile</span></span><br><span class="line">TOPNAME=top</span><br><span class="line">TOP_DIR:=<span class="variable">$(<span class="built_in">dir</span> $(<span class="built_in">abspath</span> $(<span class="built_in">lastword</span> <span class="variable">$(MAKEFILE_LIST)</span>)</span>))</span><br><span class="line">VERILATOR=verilator</span><br><span class="line">VERILATOR_CFLAGS += -MMD --build -cc -O3 --x-assign fast --x-initial fast --noassert</span><br><span class="line">CFLAGS+=-DTOP_NAME=V<span class="variable">$(TOPNAME)</span></span><br><span class="line">CSRC_PATH=<span class="variable">$(TOP_DIR)</span>csrc</span><br><span class="line">VSRC_PATH=<span class="variable">$(TOP_DIR)</span>vsrc</span><br><span class="line">V_DIR=<span class="variable">$(<span class="built_in">foreach</span> <span class="built_in">dir</span>,<span class="variable">$(VSRC_PATH)</span>,$(<span class="built_in">wildcard</span> <span class="variable">$(dir)</span>/*.v)</span>)</span><br><span class="line">CPP_INC_PATH=<span class="variable">$(CSRC_PATH)</span>/INC</span><br><span class="line">CPP_SRC_PATH=<span class="variable">$(CSRC_PATH)</span>/SRC</span><br><span class="line">CPP_SRC_DIR=<span class="variable">$(<span class="built_in">foreach</span> <span class="built_in">dir</span>,<span class="variable">$(CPP_SRC_PATH)</span>,$(<span class="built_in">wildcard</span> <span class="variable">$(dir)</span>/*.cpp)</span>)</span><br><span class="line">BUILD_PATH=<span class="variable">$(TOP_DIR)</span>build</span><br><span class="line">OBJ_PATH=<span class="variable">$(BUILD_PATH)</span>/temp</span><br><span class="line">BIN_PATH=<span class="variable">$(BUILD_PATH)</span>/bin</span><br><span class="line">BIN=<span class="variable">$(BIN_PATH)</span>/<span class="variable">$(TOPNAME)</span></span><br><span class="line">WAVE_DIR=<span class="variable">$(BIN_PATH)</span>/wave.vcd</span><br><span class="line"></span><br><span class="line"><span class="section">all: build_prepare <span class="variable">$(BIN)</span></span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(WAVE_DIR)</span>: <span class="variable">$(BIN)</span></span><br><span class="line">        @cd <span class="variable">$(BIN_PATH)</span> &amp;&amp; ./<span class="variable">$(TOPNAME)</span></span><br><span class="line"></span><br><span class="line"><span class="section">run:<span class="variable">$(WAVE_DIR)</span></span></span><br><span class="line">        @echo <span class="string">&quot;&gt; RUN <span class="variable">$^</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">sim: <span class="variable">$(WAVE_DIR)</span></span></span><br><span class="line">        @echo <span class="string">&quot;&gt; SIM <span class="variable">$^</span>&quot;</span></span><br><span class="line">        @gtkwave <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(BIN)</span>: <span class="variable">$(V_DIR)</span> <span class="variable">$(CPP_SRC_DIR)</span></span><br><span class="line">        @rm -rf <span class="variable">$(OBJ_PATH)</span></span><br><span class="line">        <span class="variable">$(<span class="built_in">foreach</span> vfile, <span class="variable">$(V_DIR)</span>, $(info + V <span class="variable">$(vfile)</span>)</span>)</span><br><span class="line">        <span class="variable">$(<span class="built_in">foreach</span> cppfile, <span class="variable">$(CPP_SRC_DIR)</span>, $(info + CPP <span class="variable">$(cppfile)</span>)</span>)</span><br><span class="line">        @<span class="variable">$(VERILATOR)</span> <span class="variable">$(VERILATOR_CFLAGS)</span> \</span><br><span class="line">        --top-module <span class="variable">$(TOPNAME)</span> \</span><br><span class="line">        <span class="variable">$^</span> -I<span class="variable">$(CPP_INC_PATH)</span> <span class="variable">$(CFLAGS)</span> \</span><br><span class="line">        --Mdir <span class="variable">$(OBJ_PATH)</span> --trace --exe \</span><br><span class="line">        -o <span class="variable">$(BIN)</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: all run sim build_prepare clean</span></span><br><span class="line"></span><br><span class="line"><span class="section">build_prepare:</span></span><br><span class="line">        @if [ ! -d <span class="variable">$(BUILD_PATH)</span> ]; then \</span><br><span class="line">        mkdir -p <span class="variable">$(OBJ_PATH)</span>; \</span><br><span class="line">        mkdir -p <span class="variable">$(BIN_PATH)</span>; \</span><br><span class="line">        fi</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        @echo <span class="string">&quot;- RM <span class="variable">$(BUILD_PATH)</span>&quot;</span></span><br><span class="line">        @rm -rf <span class="variable">$(BUILD_PATH)</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./csrc/SRC/main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;verilated.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;verilated_vcd_c.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Vtop.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">VerilatedContext* contextp = <span class="literal">NULL</span>;</span><br><span class="line">VerilatedVcdC* tfp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> Vtop* top;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">step_and_dump_wave</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    top-&gt;<span class="built_in">eval</span>();</span><br><span class="line">    contextp-&gt;<span class="built_in">timeInc</span>(<span class="number">1</span>);</span><br><span class="line">    tfp-&gt;<span class="built_in">dump</span>(contextp-&gt;<span class="built_in">time</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sim_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    contextp = <span class="keyword">new</span> VerilatedContext;</span><br><span class="line">    tfp = <span class="keyword">new</span> VerilatedVcdC;</span><br><span class="line">    top = <span class="keyword">new</span> Vtop;</span><br><span class="line">    contextp-&gt;<span class="built_in">traceEverOn</span>(<span class="literal">true</span>);</span><br><span class="line">    top-&gt;<span class="built_in">trace</span>(tfp, <span class="number">3</span>);</span><br><span class="line">    tfp-&gt;<span class="built_in">open</span>(<span class="string">&quot;./wave.vcd&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sim_exit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">step_and_dump_wave</span>();</span><br><span class="line">    tfp-&gt;<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sim_init</span>();</span><br><span class="line">    <span class="comment">// 你的测试代码</span></span><br><span class="line">    <span class="built_in">sim_exit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接入<code>Nvboard</code>在这里不做说明, 想要了解的可以看我的<a href="https://gitee.com/sin-kider/verilog_learn"><code>verilog_learn</code></a>项目<del>代码写得烂, 各位大佬见谅</del></p><h2 id="数电实验习题"><a href="#数电实验习题" class="headerlink" title="数电实验习题"></a>数电实验习题</h2><h3 id="实验一-选择器"><a href="#实验一-选择器" class="headerlink" title="实验一 选择器"></a>实验一 选择器</h3><p>单说二选一选择器的话还是挺简单的, 一句<code>assign</code>就能解决, 当然也可以选择<code>if</code>, <code>case</code>或者使用<code>MuxKey</code>模板等<br>下面是实验验收内容<strong>二位四选一选择器</strong>的代码</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> mux241 (</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] X,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>] Y,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">1</span>:<span class="number">0</span>] F</span><br><span class="line">);</span><br><span class="line">    MuxKey <span class="variable">#(4, 2, 2)</span> i0 (F, Y, &#123;</span><br><span class="line">        <span class="number">2&#x27;b00</span>, X[<span class="number">1</span>:<span class="number">0</span>],</span><br><span class="line">        <span class="number">2&#x27;b01</span>, X[<span class="number">3</span>:<span class="number">2</span>],</span><br><span class="line">        <span class="number">2&#x27;b10</span>, X[<span class="number">5</span>:<span class="number">4</span>],</span><br><span class="line">        <span class="number">2&#x27;b11</span>, X[<span class="number">7</span>:<span class="number">6</span>]</span><br><span class="line">    &#125;); <span class="comment">// #(4, 2, 2) 4个键值对 2位输入 2位输出</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>一个小问题: 接入<code>nvboard</code>时延迟极高, 初次点击到实际显示大概需要半分钟左右, 花了很多时间去RTFSC后发现<code>src/nvboard.cpp</code>的宏定义<code>FPS</code>会影响程序运行, 将默认值<code>60</code>改为<code>240</code>后问题解决. (<code>github</code>源项目的<code>issue</code>也有人问这个问题, 我去那个<code>issue</code>反应了一下, 希望能帮到一些人)</p><h3 id="实验二-译码器和编码器"><a href="#实验二-译码器和编码器" class="headerlink" title="实验二 译码器和编码器"></a>实验二 译码器和编码器</h3><p>译码器还比较简单, 本质就是将输入的编码转换为对应的数据输出, <code>case</code>与<code>MuxKey</code>模块都能做到. 文档还给出一种新的方式: <code>for</code>语句, 可以重复语句.</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> decode38(x,en,y);</span><br><span class="line">  <span class="keyword">input</span>  [<span class="number">2</span>:<span class="number">0</span>] x;</span><br><span class="line">  <span class="keyword">input</span>  en;</span><br><span class="line">  <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>]y;</span><br><span class="line">  <span class="keyword">integer</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">always</span> @(x <span class="keyword">or</span> en)</span><br><span class="line">    <span class="keyword">if</span> (en) <span class="keyword">begin</span></span><br><span class="line">      <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt;= <span class="number">7</span>; i = i+<span class="number">1</span>)</span><br><span class="line">          <span class="keyword">if</span>(x == i)</span><br><span class="line">                y[i] = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">                y[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      y = <span class="number">8&#x27;b00000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>编码器与译码器相似, 不过是将输入的数据进行编码后输出.<br>下面是实验验收内容<strong>8-3优先编码器与七段数码管显示</strong>的代码</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> encode83 (</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] in,</span><br><span class="line">    <span class="keyword">input</span> en,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] out</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">always</span> @(in <span class="keyword">or</span> en) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (en) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">integer</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i = i + <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span> (in[i] == <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">                    out = i[<span class="number">2</span>:<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            out = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> seg(</span><br><span class="line">  <span class="keyword">input</span> [<span class="number">2</span>:<span class="number">0</span>] in,</span><br><span class="line">  <span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] seg</span><br><span class="line">);</span><br><span class="line">    MuxKey <span class="variable">#(8, 3, 8)</span> MuxKey_1(seg, in, &#123;</span><br><span class="line">        <span class="number">3&#x27;b000</span>, <span class="number">8&#x27;b00000011</span>,</span><br><span class="line">        <span class="number">3&#x27;b001</span>, <span class="number">8&#x27;b10011111</span>,</span><br><span class="line">        <span class="number">3&#x27;b010</span>, <span class="number">8&#x27;b00100101</span>,</span><br><span class="line">        <span class="number">3&#x27;b011</span>, <span class="number">8&#x27;b00001101</span>,</span><br><span class="line">        <span class="number">3&#x27;b100</span>, <span class="number">8&#x27;b10011001</span>,</span><br><span class="line">        <span class="number">3&#x27;b101</span>, <span class="number">8&#x27;b01001001</span>,</span><br><span class="line">        <span class="number">3&#x27;b110</span>, <span class="number">8&#x27;b01000001</span>,</span><br><span class="line">        <span class="number">3&#x27;b111</span>, <span class="number">8&#x27;b00011111</span></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h3 id="实验三-加法器与ALU"><a href="#实验三-加法器与ALU" class="headerlink" title="实验三 加法器与ALU"></a>实验三 加法器与ALU</h3><p>加法器, <del>不就是个算加法的吗</del>数字系统基本单元之一, 其他运算基本都可以通过加法器来实现  </p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> adder (</span><br><span class="line">    <span class="keyword">input</span> a,</span><br><span class="line">    <span class="keyword">input</span> b,</span><br><span class="line">    <span class="keyword">output</span> sum,</span><br><span class="line">    <span class="keyword">output</span> cout</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">assign</span> &#123;cout, sum&#125; = a + b;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>ALU, 在CPU中，ALU的功能除了加减法运算之外，往往还包含逻辑运算、移位、乘除法、比较大小等等<br>我在按照要求写ALU的时候一直在研究原码转补码, 后来发现要求中输入就是补码, 直接用就完了  </p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> ALU (</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> <span class="keyword">signed</span> [<span class="number">3</span>:<span class="number">0</span>] a,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> <span class="keyword">signed</span> [<span class="number">3</span>:<span class="number">0</span>] b,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">2</span>:<span class="number">0</span>] cmd,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> <span class="keyword">signed</span> [<span class="number">3</span>:<span class="number">0</span>] out</span><br><span class="line">);</span><br><span class="line"><span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span> (cmd)</span><br><span class="line">        <span class="number">3&#x27;b000</span>: out = a + b;</span><br><span class="line">        <span class="number">3&#x27;b001</span>: out = a - b;</span><br><span class="line">        <span class="number">3&#x27;b010</span>: out = ~a;</span><br><span class="line">        <span class="number">3&#x27;b011</span>: out = a &amp; b;</span><br><span class="line">        <span class="number">3&#x27;b100</span>: out = a | b;</span><br><span class="line">        <span class="number">3&#x27;b101</span>: out = a ^ b;</span><br><span class="line">        <span class="number">3&#x27;b110</span>: out = (a &lt; b) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="number">3&#x27;b111</span>: out = (a == b) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">default</span>: out = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h3 id="实验六-移位寄存器及桶形移位器"><a href="#实验六-移位寄存器及桶形移位器" class="headerlink" title="实验六 移位寄存器及桶形移位器"></a>实验六 移位寄存器及桶形移位器</h3><p>移位寄存器在时钟的触发沿，根据其控制信号，将存储在其中的数据向某个方向移动一位。移位寄存器也是数字系统的常用器件  </p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Q &lt;= &#123;Q[<span class="number">0</span>],Q[<span class="number">7</span>:<span class="number">1</span>]&#125;; <span class="comment">//循环右移</span></span><br><span class="line">Q &lt;= &#123;Q[<span class="number">7</span>],Q[<span class="number">7</span>:<span class="number">1</span>]&#125;; <span class="comment">//算术右移</span></span><br></pre></td></tr></table></figure><p>桶形移位器就是在移位寄存器的基础上, 添加了更多功能, 拥有比后者更高的效率<br>下面是实验验收内容<strong>利用移位寄存器实现随机数发生器</strong>的代码</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> shift_random (</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> reset,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] in_number,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] out_number</span><br><span class="line">);</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> reset) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(reset) <span class="keyword">begin</span></span><br><span class="line">        out_number = in_number;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        out_number = &#123;^&#123;out_number[<span class="number">4</span>:<span class="number">2</span>],out_number[<span class="number">0</span>]&#125;,out_number[<span class="number">7</span>:<span class="number">1</span>]&#125;;</span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> seg(</span><br><span class="line">  <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] in,</span><br><span class="line">  <span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] seg</span><br><span class="line">);</span><br><span class="line">    MuxKey <span class="variable">#(16, 4, 8)</span> MuxKey_1(seg, in, &#123;</span><br><span class="line">        <span class="number">4&#x27;b0000</span>, <span class="number">8&#x27;b00000011</span>, <span class="comment">// 0</span></span><br><span class="line">        <span class="number">4&#x27;b0001</span>, <span class="number">8&#x27;b10011111</span>, <span class="comment">// 1</span></span><br><span class="line">        <span class="number">4&#x27;b0010</span>, <span class="number">8&#x27;b00100101</span>, <span class="comment">// 2</span></span><br><span class="line">        <span class="number">4&#x27;b0011</span>, <span class="number">8&#x27;b00001101</span>, <span class="comment">// 3</span></span><br><span class="line">        <span class="number">4&#x27;b0100</span>, <span class="number">8&#x27;b10011001</span>, <span class="comment">// 4</span></span><br><span class="line">        <span class="number">4&#x27;b0101</span>, <span class="number">8&#x27;b01001001</span>, <span class="comment">// 5</span></span><br><span class="line">        <span class="number">4&#x27;b0110</span>, <span class="number">8&#x27;b01000001</span>, <span class="comment">// 6</span></span><br><span class="line">        <span class="number">4&#x27;b0111</span>, <span class="number">8&#x27;b00011111</span>, <span class="comment">// 7</span></span><br><span class="line">        <span class="number">4&#x27;b1000</span>, <span class="number">8&#x27;b00000001</span>, <span class="comment">// 8</span></span><br><span class="line">        <span class="number">4&#x27;b1001</span>, <span class="number">8&#x27;b00001001</span>, <span class="comment">// 9</span></span><br><span class="line">        <span class="number">4&#x27;b1010</span>, <span class="number">8&#x27;b00010001</span>, <span class="comment">// A</span></span><br><span class="line">        <span class="number">4&#x27;b1011</span>, <span class="number">8&#x27;b11000001</span>, <span class="comment">// B</span></span><br><span class="line">        <span class="number">4&#x27;b1100</span>, <span class="number">8&#x27;b01100011</span>, <span class="comment">// C</span></span><br><span class="line">        <span class="number">4&#x27;b1101</span>, <span class="number">8&#x27;b10000101</span>, <span class="comment">// D</span></span><br><span class="line">        <span class="number">4&#x27;b1110</span>, <span class="number">8&#x27;b01100001</span>, <span class="comment">// E</span></span><br><span class="line">        <span class="number">4&#x27;b1111</span>, <span class="number">8&#x27;b01110001</span>  <span class="comment">// F</span></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h3 id="实验七-状态机及键盘输入"><a href="#实验七-状态机及键盘输入" class="headerlink" title="实验七 状态机及键盘输入"></a>实验七 状态机及键盘输入</h3><p>有限状态机FSM（Finite State Machine）简称状态机，是一个在有限个状态间进行转换和动作的计算模型。有限状态机含有一个起始状态、一个输入列表（列表中包含了所有可能的输入信号序列）、一个状态转移函数和一个输出端，状态机在工作时由状态转移函数根据当前状态和输入信号确定下一个状态和输出。状态机一般都从起始状态开始，根据输入信号由状态转移函数决定状态机的下一个状态<br>有限状态机是数字电路系统中十分重要的电路模块，是一种输出取决于过去输入和当前输入的时序逻辑电路，它是组合逻辑电路和时序逻辑电路的组合。其中组合逻辑分为两个部分，一个是用于产生有限状态机下一个状态的次态逻辑，另一个是用于产生输出信号的输出逻辑，次态逻辑的功能是确定有限状态机的下一个状态；输出逻辑的功能是确定有限状态机的输出。除了输入和输出外，状态机还有一组具有“记忆”功能的寄存器，这些寄存器的功能是记忆有限状态机的内部状态，常被称作状态寄存器<br>下面是实验验收内容<strong>实现单个按键的ASCII码显示</strong>的代码</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 上层调用</span></span><br><span class="line"><span class="comment">    reg [7:0] data,key_count;</span></span><br><span class="line"><span class="comment">    reg key_down;</span></span><br><span class="line"><span class="comment">    seg seg_1(&#123;key_down,data[3:0]&#125;, seg0);</span></span><br><span class="line"><span class="comment">    seg seg_2(&#123;key_down,data[7:4]&#125;, seg1);</span></span><br><span class="line"><span class="comment">    seg seg_3(&#123;key_down,key_count[3:0]&#125;, seg2);</span></span><br><span class="line"><span class="comment">    seg seg_4(&#123;key_down,key_count[7:4]&#125;, seg3);</span></span><br><span class="line"><span class="comment">    ps2_keyboard ps2_keyboard_1(</span></span><br><span class="line"><span class="comment">      .clk(clk),</span></span><br><span class="line"><span class="comment">      .clrn(~rst),</span></span><br><span class="line"><span class="comment">      .ps2_clk(ps2_clk),</span></span><br><span class="line"><span class="comment">      .ps2_data(ps2_data),</span></span><br><span class="line"><span class="comment">      .data(data),</span></span><br><span class="line"><span class="comment">      .key_count(key_count),</span></span><br><span class="line"><span class="comment">      .key_down(key_down)</span></span><br><span class="line"><span class="comment">   );</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> ps2_keyboard(clk,clrn,ps2_clk,ps2_data,data,key_count,key_down);</span><br><span class="line">    <span class="keyword">input</span> clk,clrn,ps2_clk,ps2_data;</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] data,key_count;</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> key_down;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">9</span>:<span class="number">0</span>] buffer; <span class="comment">// ps2_data bits</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] count; <span class="comment">// count ps2_data bits</span></span><br><span class="line">    <span class="comment">// detect falling edge of ps2_clk</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] ps2_clk_sync;</span><br><span class="line">    <span class="keyword">reg</span> keyup_flag;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">       ps2_clk_sync &lt;= &#123;ps2_clk_sync[<span class="number">1</span>:<span class="number">0</span>],ps2_clk&#125;;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">wire</span> sampling = ps2_clk_sync[<span class="number">2</span>] &amp; ~ps2_clk_sync[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">       <span class="keyword">if</span> (clrn == <span class="number">0</span>) <span class="keyword">begin</span> <span class="comment">// reset</span></span><br><span class="line">          count &lt;= <span class="number">0</span>; </span><br><span class="line">       <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">          <span class="keyword">if</span> (sampling) <span class="keyword">begin</span></span><br><span class="line">             <span class="keyword">if</span> (count == <span class="number">4&#x27;d10</span>) <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span> ((buffer[<span class="number">0</span>] == <span class="number">0</span>) &amp;&amp; <span class="comment">// start bit</span></span><br><span class="line">                    (ps2_data) &amp;&amp; <span class="comment">// stop bit</span></span><br><span class="line">                    (^buffer[<span class="number">9</span>:<span class="number">1</span>])) <span class="keyword">begin</span> <span class="comment">// odd parity</span></span><br><span class="line">                    data &lt;= buffer[<span class="number">8</span>:<span class="number">1</span>]; <span class="comment">// kbd scan code</span></span><br><span class="line">                    <span class="keyword">if</span> (buffer[<span class="number">8</span>:<span class="number">1</span>] == <span class="number">8&#x27;hF0</span>) <span class="keyword">begin</span></span><br><span class="line">                        key_count &lt;= key_count + <span class="number">1</span>;</span><br><span class="line">                        keyup_flag &lt;= <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                        <span class="keyword">if</span> (keyup_flag == <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">                            key_down &lt;= <span class="number">0</span>;</span><br><span class="line">                            keyup_flag &lt;= <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">end</span></span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                            key_down &lt;= <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                count &lt;= <span class="number">0</span>; <span class="comment">// for next</span></span><br><span class="line">             <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                buffer[count] &lt;= ps2_data; <span class="comment">// store ps2_data</span></span><br><span class="line">                count &lt;= count + <span class="number">3&#x27;b1</span>;</span><br><span class="line">             <span class="keyword">end</span></span><br><span class="line">          <span class="keyword">end</span></span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> seg(</span><br><span class="line">  <span class="keyword">input</span> [<span class="number">4</span>:<span class="number">0</span>] in,</span><br><span class="line">  <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] seg</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span> (in)</span><br><span class="line">            <span class="number">5&#x27;b10000</span>: seg = <span class="number">8&#x27;b0000_0011</span>;</span><br><span class="line">            <span class="number">5&#x27;b10001</span>: seg = <span class="number">8&#x27;b1001_1111</span>;</span><br><span class="line">            <span class="number">5&#x27;b10010</span>: seg = <span class="number">8&#x27;b0010_0101</span>;</span><br><span class="line">            <span class="number">5&#x27;b10011</span>: seg = <span class="number">8&#x27;b0000_1101</span>;</span><br><span class="line">            <span class="number">5&#x27;b10100</span>: seg = <span class="number">8&#x27;b1001_1001</span>;</span><br><span class="line">            <span class="number">5&#x27;b10101</span>: seg = <span class="number">8&#x27;b0100_1001</span>;</span><br><span class="line">            <span class="number">5&#x27;b10110</span>: seg = <span class="number">8&#x27;b0100_0001</span>;</span><br><span class="line">            <span class="number">5&#x27;b10111</span>: seg = <span class="number">8&#x27;b0001_1111</span>;</span><br><span class="line">            <span class="number">5&#x27;b11000</span>: seg = <span class="number">8&#x27;b0000_0001</span>;</span><br><span class="line">            <span class="number">5&#x27;b11001</span>: seg = <span class="number">8&#x27;b0000_1001</span>;</span><br><span class="line">            <span class="number">5&#x27;b11010</span>: seg = <span class="number">8&#x27;b0001_0001</span>;</span><br><span class="line">            <span class="number">5&#x27;b11011</span>: seg = <span class="number">8&#x27;b1100_0001</span>;</span><br><span class="line">            <span class="number">5&#x27;b11100</span>: seg = <span class="number">8&#x27;b0110_0011</span>;</span><br><span class="line">            <span class="number">5&#x27;b11101</span>: seg = <span class="number">8&#x27;b1000_0101</span>;</span><br><span class="line">            <span class="number">5&#x27;b11110</span>: seg = <span class="number">8&#x27;b0110_0001</span>;</span><br><span class="line">            <span class="number">5&#x27;b11111</span>: seg = <span class="number">8&#x27;b0111_0001</span>;</span><br><span class="line">            <span class="keyword">default</span>:  seg = <span class="number">8&#x27;b1111_1111</span>;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> verilog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ysyx </tag>
            
            <tag> Linux </tag>
            
            <tag> verilator </tag>
            
            <tag> verilog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ysyx-预学习阶段-C语言学习</title>
      <link href="/2023-03-11-ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023-03-11-ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="ysyx-预学习阶段-C语言学习"><a href="#ysyx-预学习阶段-C语言学习" class="headerlink" title="ysyx-预学习阶段-C语言学习"></a>ysyx-预学习阶段-C语言学习</h1><h2 id="代码仓库及相关网页"><a href="#代码仓库及相关网页" class="headerlink" title="代码仓库及相关网页"></a>代码仓库及相关网页</h2><ul><li><a href="https://gitee.com/sin-kider/c_learn">Sin_kider&#x2F;c_learn</a></li><li><a href="https://ysyx.oscc.cc/">ysyx官方网址</a></li><li><a href="https://www.cntofu.com/book/25/index.html">Learn C the hard way</a></li></ul><h2 id="一生一芯实验报告目录"><a href="#一生一芯实验报告目录" class="headerlink" title="一生一芯实验报告目录"></a>一生一芯实验报告目录</h2><ul><li><a href="https://sin-kider.github.io/2023/03/04/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-Linux-WSL%E5%AE%89%E8%A3%85/">ysyx-预学习阶段-Linux-WSL安装</a></li><li><a href="https://sin-kider.github.io/2023/03/04/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-Linux-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/">ysyx-预学习阶段-Linux-基本使用</a></li><li><a href="https://sin-kider.github.io/2023/03/11/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/">ysyx-预学习阶段-C语言学习</a> ✨</li><li><a href="https://sin-kider.github.io/2023/03/18/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-verilog%E5%AD%A6%E4%B9%A0-%E6%90%AD%E5%BB%BAverilator%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83">ysyx-预学习阶段-verilog学习-搭建verilator仿真环境</a></li><li><a href="https://sin-kider.github.io/2023/03/23/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-PA1-NEMU">ysyx-预学习阶段-PA1-NEMU</a></li><li><a href="https://sin-kider.github.io/2023/03/25/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-%E5%A6%82%E4%BD%95%E7%A7%91%E5%AD%A6%E5%9C%B0%E6%8F%90%E9%97%AE-%E8%AF%BB%E5%90%8E%E6%84%9F">ysyx-预学习阶段-如何科学地提问-读后感</a></li><li><a href="https://sin-kider.github.io/2023/04/01/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-%E6%80%BB%E7%BB%93">ysyx-预学习阶段-总结</a></li><li><a href="https://sin-kider.github.io/2023/04/07/ysyx-B%E9%98%B6%E6%AE%B5-%E7%94%A8RTL%E5%AE%9E%E7%8E%B0%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%A4%84%E7%90%86%E5%99%A8-%E7%94%A8Chisel%E5%AE%9E%E7%8E%B0%E5%8D%95%E5%91%A8%E6%9C%9Friscv64%E5%A4%84%E7%90%86%E5%99%A8">ysyx-B阶段-用RTL实现最简单的处理器-用Chisel实现单周期riscv64处理器</a></li><li><a href="https://sin-kider.github.io/2023/04/07/ysyx-B%E9%98%B6%E6%AE%B5-%E6%94%AF%E6%8C%81RV64IM%E7%9A%84NEMU-%E7%94%A8NEMU%E8%BF%90%E8%A1%8Criscv64%E7%9A%84%E7%A8%8B%E5%BA%8F">ysyx-B阶段-支持RV64IM的NEMU-用NEMU运行riscv64的程序</a></li></ul><h2 id="Learn-C-the-hard-way-习题"><a href="#Learn-C-the-hard-way-习题" class="headerlink" title="Learn C the hard way 习题"></a>Learn C the hard way 习题</h2><h3 id="ex1"><a href="#ex1" class="headerlink" title="ex1"></a>ex1</h3><ol><li>在你的文本编辑器中打开<code>ex1</code>文件，随机修改或删除一部分，之后运行它看看发生了什么<ul><li>产生了各种不同的报错</li><li>就算原封不动进行编译也会产生错误<code>warning: implicit declaration of function ‘puts’</code></li></ul></li><li>再多打印5行文本或者其它比<code>&quot;Hello world.&quot;</code>更复杂的东西<ul><li>请查看分支<code>ex1</code>代码</li></ul></li><li>执行<code>man 3 puts</code>来阅读这个函数和其它函数的文档<ul><li>输出了pust函数的使用方法(后续类似习题将跳过说明)</li></ul></li></ol><h3 id="ex2"><a href="#ex2" class="headerlink" title="ex2"></a>ex2</h3><ol><li>创建目标<code>all:ex1</code>，可以以单个命令<code>make</code>构建<code>ex1</code><ul><li>事先已写好<code>Makefile</code>, 请查看分支<code>ex2</code>代码</li></ul></li><li>阅读<code>man make</code>来了解关于如何执行它的更多信息<ul><li>已阅😊</li></ul></li><li>阅读<code>man cc</code>来了解关于<code>-Wall</code>和<code>-g</code>行为的更多信息<ul><li>已阅😊</li></ul></li><li>在互联网上搜索Makefile文件，看看你是否能改进你的文件<ul><li>学习<code>nemu</code>与<code>nvboard</code>时已写好相对完整的<code>Makefile</code></li></ul></li><li>在另一个C语言项目中找到<code>Makefile</code>文件，并且尝试理解它做了什么<ul><li>同上</li></ul></li></ol><h3 id="ex3"><a href="#ex3" class="headerlink" title="ex3"></a>ex3</h3><ol><li>找到尽可能多的方法使<code>ex3</code>崩溃<ul><li>删除全部或部分分号, 括号, 关键词, 引号</li><li>printf不提供参数</li></ul></li><li>执行man 3 printf来阅读其它可用的’%’格式化占位符。如果你在其它语言中使用过它们，应该看着非常熟悉<ul><li>已阅😊</li></ul></li><li>将<code>ex3</code>添加到你的<code>Makefile</code>的<code>all</code>列表中。到目前为止，可以使用<code>make clean all</code>来构建你所有的练习<ul><li>我的makefile未遵从书中所给的方式编写, 所以跳过</li></ul></li><li>将<code>ex3</code>添加到你的<code>Makefile</code>的<code>clean</code>列表中。当你需要的时候使用<code>make clean</code>可以删除它<ul><li>同上</li></ul></li></ol><h3 id="ex4"><a href="#ex4" class="headerlink" title="ex4"></a>ex4</h3><ol><li>按照上面的指导，使用<code>Valgrind</code>和编译器修复这个程序<ul><li>修改结果见代码</li><li>makefile中添加了val选项, 可直接用<code>Valgrind</code>运行程序</li></ul></li><li>在互联网上查询<code>Valgrind</code>相关的资料<ul><li>已阅😊</li></ul></li><li>下载另一个程序并手动构建它。尝试一些你已经使用，但从来没有手动构建的程序<ul><li>已做😊</li></ul></li><li>看看<code>Valgrind</code>的源码是如何在目录下组织的，并且阅读它的<code>Makefile</code>文件<ul><li>看的我脑壳疼</li></ul></li></ol><h3 id="ex5"><a href="#ex5" class="headerlink" title="ex5"></a>ex5</h3><ol><li>对于每一行，写出你不理解的符号，并且看看是否能猜出它们的意思。在纸上写下你的猜测，你可以在以后检查它，看看是否正确<ul><li>已学习过全部内容</li></ul></li><li>回头去看之前几个练习的源代码，并且像这样分解代码，来看看你是否了解它们。写下你不了解和不能自己解释的东西<ul><li>同上</li></ul></li></ol><h3 id="ex6"><a href="#ex6" class="headerlink" title="ex6"></a>ex6</h3><ol><li>寻找其他通过修改printf使这段C代码崩溃的方法<ul><li>1️⃣修改格式控制符</li><li>2️⃣修改参数位置</li><li>3️⃣删除参数</li></ul></li><li>搜索<code>“printf格式化”</code>，试着使用一些高级的占位符<ul><li>%2d %.2f %x</li></ul></li><li>研究可以用几种方法打印数字<ul><li>%o %x</li></ul></li><li>试着打印空字符串，即<code>&quot;&quot;</code><ul><li>结果输出了<code>%</code></li></ul></li></ol><h3 id="ex7"><a href="#ex7" class="headerlink" title="ex7"></a>ex7</h3><ol><li>把为universe_of_defects赋值的数改为不同的大小，观察编译器的警告<ul><li>过大时发生警告<code>warning: integer constant is too large for its type</code></li></ul></li><li>这些巨大的数字实际上打印成了什么<ul><li>打印结果有负数有正数</li></ul></li><li>将<code>long</code>改为<code>unsigned long</code>，并试着找到对它来说太大的数字<ul><li>😁找到了(doge)</li></ul></li><li>上网搜索<code>unsigned</code>做了什么<ul><li>将符号位去除, 全部用于表示数字</li></ul></li><li>试着自己解释（在下个练习之前）为什么<code>char</code>可以和<code>int</code>相乘<ul><li>char是使用数进行存储, 本质上是数字, 所以可以参与计算</li></ul></li></ol><h3 id="ex8"><a href="#ex8" class="headerlink" title="ex8"></a>ex8</h3><ol><li>尝试使用<code>areas[0] = 100;</code>以及相似的操作对<code>areas</code>的元素赋值<ul><li>修改结果见代码😎</li></ul></li><li>尝试对<code>name</code>和<code>full_name</code>的元素赋值<ul><li>修改结果见代码😎</li></ul></li><li>尝试将<code>areas</code>的一个元素赋值为<code>name</code>中的字符<ul><li>修改结果见代码😎</li></ul></li><li>上网搜索在不同的CPU上整数所占的不同大小<ul><li>根据CPU位数不同整数的占用也不同,常见的有2字节与4字节</li></ul></li></ol><h3 id="ex9"><a href="#ex9" class="headerlink" title="ex9"></a>ex9</h3><ol><li>将一些字符赋给<code>numbers</code>的元素，之后用<code>printf</code>一次打印一个字符，你会得到什么编译器警告<ul><li>我将字符以几种方式赋值给<code>numbers</code>后编译器并未报错🧐(以前写c也这样干过, 也没遇见过报错啊)</li></ul></li><li>对<code>names</code>执行上述的相反操作，把<code>names</code>当成<code>int</code>数组，并一次打印一个<code>int</code>，<code>Valgrind</code>会提示什么<ul><li>还是没报错, 是我问题吗🧐</li></ul></li><li>有多少种其它的方式可以用来打印它<ul><li>1️⃣for</li><li>2️⃣while</li><li>3️⃣四个printf</li><li>4️⃣有些阴间想法就不在这里写了😋</li></ul></li><li>如果一个字符数组占四个字节，一个整数也占<code>4</code>个字节，你可以像整数一样使用整个<code>name</code>吗？你如何用黑魔法实现它？<ul><li>读取: 通过位运算读取字符数组每一位后, 计算实际的值; 写入: 位运算将待写入的值转为二进制, 高位为符号位(这题出现在这是不是有问题🤔, 或者是我想复杂了)</li></ul></li><li>拿出一张纸，将每个数组画成一排方框，之后在纸上画出代码中的操作，看看是否正确<ul><li>懒🥲</li></ul></li><li>将<code>name</code>转换成<code>another</code>的形式，看看代码是否能正常工作<ul><li>挺正常😊(至少比我正常)</li></ul></li></ol><h3 id="ex10"><a href="#ex10" class="headerlink" title="ex10"></a>ex10</h3><ol><li>弄清楚在<code>for</code>循环的每一部分你都可以放置什么样的代码<ul><li>这个确实之前没有仔细研究过, 花了点时间总结了一下<ul><li>第一部分可以定义和变量赋值, 多个赋值可用<code>,</code>隔开</li><li>第二部分用于判断, 可写判断语句, 包括有返回值的函数</li><li>第三部分想些啥写啥, 多个语句可用<code>,</code>隔开, 但多用于控制循环</li></ul></li></ul></li><li>查询如何使用<code>&#39;,&#39;</code>（逗号）字符来在for循环的每一部分中，<code>&#39;;&#39;</code>（分号）之间分隔多条语句<ul><li>上一题有提到, 略</li></ul></li><li>查询<code>NULL</code>是什么东西，尝试将它用做<code>states</code>的一个元素，看看它会打印出什么<ul><li>在<code>stdio.h</code>中定义为<code>#define NULL ((void*)0)</code>, 一般用于定义空指针, 打印出来是一段字符<code>(null)</code>(虽然我觉得这里应该会报错😔)</li></ul></li><li>看看你是否能在打印之前将states的一个元素赋值给argv中的元素，再试试相反的操作<ul><li>两种都可以😎</li></ul></li></ol><h3 id="ex11"><a href="#ex11" class="headerlink" title="ex11"></a>ex11</h3><ol><li>让这些循环倒序执行，通过使用<code>i--</code>从<code>argc</code>开始递减直到<code>0</code>。你可能需要做一些算数操作让数组的下标正常工作<ul><li>修改结果见代码😎</li></ul></li><li>使用<code>while</code>循环将<code>argv</code>中的值复制到<code>states</code><ul><li>修改结果见代码😎</li></ul></li><li>让这个复制循环不会执行失败，即使<code>argv</code>之中有很多元素也不会全部放进<code>states</code><ul><li>修改结果见代码😎</li></ul></li><li>研究你是否真正复制了这些字符串。答案可能会让你感到意外和困惑<ul><li>没, 就是改了个地址, 指向了同一个地址而已</li></ul></li></ol><h3 id="ex12"><a href="#ex12" class="headerlink" title="ex12"></a>ex12</h3><ol><li>我已经向你简短地介绍了<code>&amp;&amp;</code>，它执行“与”操作。上网搜索与之不同的“布尔运算符”<ul><li>会了, 不想搜😎</li></ul></li><li>为这个程序编写更多的测试用例，看看你会写出什么<ul><li>这个也会, 不想写😎</li></ul></li><li>回到练习10和11，使用if语句使循环提前退出<ul><li>会…算了, 我写(不然太摆了😂, 项目代码没变是因为我提交了, 懒得回头再提交搞得分支太乱了)</li></ul></li><li>第一个判断所输出的话真的正确吗<ul><li>聪明的我发现不对! 还改正了!</li></ul></li></ol><h3 id="ex13"><a href="#ex13" class="headerlink" title="ex13"></a>ex13</h3><ol><li>编写另一个程序，在字母上做算术运算将它们转换为小写，并且在<code>switch</code>中移除所有额外的大写字母<ul><li>简单写了个函数, 具体看代码</li></ul></li><li>使用<code>&#39;,&#39;</code>（逗号）在<code>fo</code>r循环中初始化<code>letter</code><ul><li>修改结果见代码😎</li></ul></li><li>使用另一个for循环来让它处理你传入的所有命令行参数<ul><li>修改结果见代码😎</li></ul></li><li>将这个<code>switch</code>语句转为<code>if</code>语句，你更喜欢哪个呢<ul><li>哪个好看用哪个</li></ul></li><li>在“Y”的例子中，我在<code>if</code>代码块外面写了个<code>break</code>。这样会产生什么效果？如果把它移进<code>if</code>代码块，会发生什么？自己试着解答它，并证明你是正确的<ul><li>1️⃣执行完<code>case</code>后就结束<code>switch</code></li><li>2️⃣<code>if</code>条件满足就结束<code>switch</code>, 否则继续执行下一个<code>case</code></li></ul></li></ol><h3 id="ex14"><a href="#ex14" class="headerlink" title="ex14"></a>ex14</h3><ol><li>重新编写这些函数，使它们的数量减少。比如，你真的需要<code>can_print_it</code>吗？<ul><li>改完了, 不过我确实经常这么干</li></ul></li><li>使用<code>strlen</code>函数，让<code>print_arguments</code>知道每个字符串参数都有多长，之后将长度传入<code>print_letters</code>。然后重写<code>print_letters</code>，让它只处理固定的长度，不按照<code>&#39;\0&#39;</code>终止符。你需要<code>#include &lt;string.h&gt;</code>来实现它<ul><li>修改结果见代码😎</li></ul></li><li>使用<code>man</code>来查询<code>isalpha</code>和<code>isblank</code>的信息<ul><li>修改结果见代码😎</li></ul></li><li>上网浏览不同的人喜欢什么样的函数格式<ul><li>我倒是挺喜欢<code>allman</code>的, 但是被迫<code>Stroustrup</code></li></ul></li></ol><h3 id="ex15"><a href="#ex15" class="headerlink" title="ex15"></a>ex15</h3><ol><li>使用访问指针的方式重写所有使用数组的地方<ul><li>修改结果见代码😎</li></ul></li><li>使用访问数组的方式重写所有使用指针的地方<ul><li>修改结果见代码😎</li></ul></li><li>在其它程序中使用指针来代替数组访问<ul><li>用了, 你们看不到😎</li></ul></li><li>使用指针来处理命令行参数，就像处理<code>names</code>那样<ul><li>用了, 你们看不到😎</li></ul></li><li>将获取值和获取地址组合到一起<ul><li>修改结果见代码😎</li></ul></li><li>在程序末尾添加一个<code>for</code>循环，打印出这些指针所指向的地址。你需要在<code>printf</code>中使用<code>%p</code><ul><li>修改结果见代码😎</li></ul></li><li>对于每一种打印数组的方法，使用函数来重写程序<ul><li>用了, 你们看不到😎</li></ul></li><li>将<code>for</code>循环改为<code>while</code>循环，并且观察对于每种指针用法哪种循环更方便<ul><li>用了, 你们看不到😎(咋这么多)</li></ul></li></ol><h3 id="ex16"><a href="#ex16" class="headerlink" title="ex16"></a>ex16</h3><ol><li>如何在栈上创建结构体，就像你创建任何其它变量那样<ul><li><code>struct Person who;</code></li></ul></li><li>如何使用<code>x.y</code>而不是<code>x-&gt;y</code>来初始化结构体<ul><li>在栈区创建结构体就能用<code>x.y</code></li></ul></li><li>如何不使用指针来将结构体传给其它函数<ul><li>直接将结构体传给函数</li><li>把所有参数逐个传给函数</li></ul></li></ol><h3 id="ex17"><a href="#ex17" class="headerlink" title="ex17"></a>ex17</h3><ol><li><code>die</code>函数需要接收<code>conn</code>变量作为参数，以便执行清理并关闭它<ul><li>修改结果见代码😎</li></ul></li><li>修改代码，使其接收参数作为<code>MAX_DATA</code>和<code>MAX_ROWS</code>，将它们储存在<code>Database</code>结构体中，并且将它们写到文件。这样就可以创建任意大小的数据库<ul><li>这一题我没有想到有什么简单的方法去解决, 原本想法是将所有结构体中的char数组改为char指针, 然后通过malloc分配, 但是后续发现这一方法及其麻烦, 希望有大佬能解答.</li></ul></li><li>向数据库添加更多操作，比如<code>find</code><ul><li>修改结果见代码😎</li></ul></li><li>查询C如何打包结构体，并且试着弄清楚为什么你的文件是相应的大小<ul><li>奇妙的内存对齐</li></ul></li><li>向<code>Address</code>添加一些字段，使它们可被搜索<ul><li>感觉和第三题有点重复, 无非就是循环找匹配的项目输出</li></ul></li><li>尝试重构程序，使用单一的全局变量来储存数据库连接<ul><li>全局变量方便多了</li></ul></li><li>搜索“栈数据结构”，并且在你最喜欢的语言中实现它，然后尝试在C中实现<ul><li>相关代码在<code>stack.c</code>内</li></ul></li></ol><h3 id="ex18"><a href="#ex18" class="headerlink" title="ex18"></a>ex18</h3><ol><li>用十六进制编辑器打开ex18，接着找到函数起始处的十六进制代码序列，看看是否能在原始程序中找到函数<ul><li>找到了</li></ul></li><li>在你的十六进制编辑器中找到更多随机出现的东西并修改它们。重新运行你的程序看看发生了什么<ul><li>改了一下<code>USAGE: ex18 4 3 1 5 6</code>这句, 运行后确实变化了</li></ul></li><li>将错误的函数传给compare_cb，并看看C编辑器会报告什么错误<ul><li>我初始化了一个函数指针, 把NULL传给了指针后, 给将指针传给了函数, 但是只有<code>make</code>报错了:<code>Segmentation fault</code></li></ul></li><li>将<code>NULL</code>传给它，看看程序中会发生什么。然后运行<code>Valgrind</code>来看看它会报告什么<ul><li>怪事, 编译器报错, 但是<code>valgrind</code>没报错</li></ul></li><li>编写另一个排序算法，修改test_sorting使它接收任意的排序函数和排序函数的比较回调<ul><li>写了个选排, 菜鸡不会高级排序(doge)</li></ul></li></ol><h3 id="ex32-ex33-ex42-ex44"><a href="#ex32-ex33-ex42-ex44" class="headerlink" title="ex32 ex33 ex42 ex44"></a>ex32 ex33 ex42 ex44</h3><ol><li>关于两种链表的不同<ul><li>单向增删麻烦, 占用小</li><li>双向可进可退, 增删挺方便, 但会消耗更多的内存</li></ul></li><li>写ex33遇到的问题: 编译器提示 <code>inline</code> 函数没有定义, 在头文件中添加也无用. STFW发现三种解决方案.<ul><li>将 <code>inline</code> 函数改为 <code>static inline</code></li><li>编译选项加上 <code>-O</code> 优化</li><li>添加无 <code>inline</code> 的原型声明</li></ul></li><li>关于数据结构<ul><li>从前没想过可以这么构建<code>stack</code>与<code>queue</code>, 确实比复制一份后修改来的简单</li></ul></li><li>自己写测试有些麻烦<ul><li><del>所以偷个懒</del></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ysyx </tag>
            
            <tag> Linux </tag>
            
            <tag> C </tag>
            
            <tag> Makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ysyx-预学习阶段-Linux-基本使用</title>
      <link href="/2023-03-04-ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-Linux-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2023-03-04-ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-Linux-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="ysyx-预学习阶段-Linux-基本使用"><a href="#ysyx-预学习阶段-Linux-基本使用" class="headerlink" title="ysyx-预学习阶段-Linux-基本使用"></a>ysyx-预学习阶段-Linux-基本使用</h1><h2 id="代码仓库及相关网页"><a href="#代码仓库及相关网页" class="headerlink" title="代码仓库及相关网页"></a>代码仓库及相关网页</h2><ul><li><a href="https://ysyx.oscc.cc/">ysyx官方网址</a></li></ul><h2 id="一生一芯实验报告目录"><a href="#一生一芯实验报告目录" class="headerlink" title="一生一芯实验报告目录"></a>一生一芯实验报告目录</h2><ul><li><a href="https://sin-kider.github.io/2023/03/04/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-Linux-WSL%E5%AE%89%E8%A3%85/">ysyx-预学习阶段-Linux-WSL安装</a> </li><li><a href="https://sin-kider.github.io/2023/03/04/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-Linux-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/">ysyx-预学习阶段-Linux-基本使用</a> ✨</li><li><a href="https://sin-kider.github.io/2023/03/11/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/">ysyx-预学习阶段-C语言学习</a></li><li><a href="https://sin-kider.github.io/2023/03/18/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-verilog%E5%AD%A6%E4%B9%A0-%E6%90%AD%E5%BB%BAverilator%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83">ysyx-预学习阶段-verilog学习-搭建verilator仿真环境</a></li><li><a href="https://sin-kider.github.io/2023/03/23/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-PA1-NEMU">ysyx-预学习阶段-PA1-NEMU</a></li><li><a href="https://sin-kider.github.io/2023/03/25/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-%E5%A6%82%E4%BD%95%E7%A7%91%E5%AD%A6%E5%9C%B0%E6%8F%90%E9%97%AE-%E8%AF%BB%E5%90%8E%E6%84%9F">ysyx-预学习阶段-如何科学地提问-读后感</a></li><li><a href="https://sin-kider.github.io/2023/04/01/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-%E6%80%BB%E7%BB%93">ysyx-预学习阶段-总结</a></li><li><a href="https://sin-kider.github.io/2023/04/07/ysyx-B%E9%98%B6%E6%AE%B5-%E7%94%A8RTL%E5%AE%9E%E7%8E%B0%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%A4%84%E7%90%86%E5%99%A8-%E7%94%A8Chisel%E5%AE%9E%E7%8E%B0%E5%8D%95%E5%91%A8%E6%9C%9Friscv64%E5%A4%84%E7%90%86%E5%99%A8">ysyx-B阶段-用RTL实现最简单的处理器-用Chisel实现单周期riscv64处理器</a></li><li><a href="https://sin-kider.github.io/2023/04/07/ysyx-B%E9%98%B6%E6%AE%B5-%E6%94%AF%E6%8C%81RV64IM%E7%9A%84NEMU-%E7%94%A8NEMU%E8%BF%90%E8%A1%8Criscv64%E7%9A%84%E7%A8%8B%E5%BA%8F">ysyx-B阶段-支持RV64IM的NEMU-用NEMU运行riscv64的程序</a></li></ul><h2 id="课程概览与shell习题"><a href="#课程概览与shell习题" class="headerlink" title="课程概览与shell习题"></a>课程概览与shell习题</h2><ol><li>确认使用的SHELL<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$SHELL</span></span></span><br><span class="line">/usr/bin/zsh</span><br></pre></td></tr></table></figure></li><li>在 <code>/tmp</code> 下新建一个名为 <code>missing</code> 的文件夹<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">cd</span> /tmp</span></span><br><span class="line">/tmp $ mkdir missing</span><br><span class="line">/tmp $ find missing -type d</span><br><span class="line">missing </span><br></pre></td></tr></table></figure></li><li>用 <code>man</code> 查看程序 <code>touch</code> 的使用手册<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">man <span class="built_in">touch</span></span></span><br></pre></td></tr></table></figure></li><li>用 <code>touch</code> 在 <code>missing</code> 文件夹中新建一个叫 <code>semester</code> 的文件<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/tmp $ touch missing/semester</span><br></pre></td></tr></table></figure></li><li>将以下内容一行一行地写入 <code>semester</code> 文件<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/tmp/missing $ echo &#x27;#!/bin/sh&#x27; &gt; ./semester</span><br><span class="line">/tmp/missing $ echo &#x27;curl --head --silent https://missing.csail.mit.edu&#x27; &gt;&gt; ./semester</span><br></pre></td></tr></table></figure></li><li>尝试执行这个文件<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/tmp/missing $ chmod ugo+x semester</span><br><span class="line">/tmp/missing $ ./semester</span><br></pre></td></tr></table></figure></li><li>查看 <code>chmod</code> 的手册<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/tmp/missing $ man chmod</span><br></pre></td></tr></table></figure></li><li>使用 <code>chmod</code> 命令改变权限<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/tmp/missing $ chmod ugo+x semester</span><br></pre></td></tr></table></figure></li><li>使用 <code>|</code> 和 <code>&gt;</code> ，将 <code>semester</code> 文件输出的最后更改日期信息，写入主目录下的 <code>last-modified.txt</code> 的文件中<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/tmp/missing $ ./semester | grep -i &quot;last-modified&quot; &gt; ~/last-modified.txt</span><br><span class="line">/tmp/missing $ cd ~</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> ./last-modified.txt</span></span><br><span class="line">last-modified: Mon, 27 Feb 2023 12:16:49 GMT</span><br></pre></td></tr></table></figure></li></ol><h2 id="Shell-工具和脚本习题"><a href="#Shell-工具和脚本习题" class="headerlink" title="Shell 工具和脚本习题"></a>Shell 工具和脚本习题</h2><ol><li>阅读 <code>man ls</code> ，然后使用 <code>ls</code> 命令进行如下操作：</li></ol><ul><li>所有文件（包括隐藏文件）</li><li>文件打印以人类可以理解的格式输出 (例如，使用454M 而不是 454279954)</li><li>文件以最近访问顺序排序</li><li>以彩色文本显示输出结果<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">man <span class="built_in">ls</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -a</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l -h -a</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l -t -a</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -lath --color=auto</span></span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>编写两个bash函数 <code>marco</code> 和 <code>polo</code> 执行下面的操作<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">marco()&#123;</span><br><span class="line">    export MARCO=$(pwd)  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">polo()&#123;</span><br><span class="line">    cd &quot;$MARCO&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>编写一段bash脚本，运行如下的脚本直到它出错，将它的标准输出和标准错误流记录到文件，并在最后输出所有内容<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/env bash</span></span><br><span class="line">i=0</span><br><span class="line">while true</span><br><span class="line">do</span><br><span class="line">./random_test.sh &gt; history.log</span><br><span class="line">if [[ $? -ne 0 ]]</span><br><span class="line">then </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;error time <span class="variable">$i</span>&quot;</span></span></span><br><span class="line"> cat history.log</span><br><span class="line"> break</span><br><span class="line">fi</span><br><span class="line"> i=$(($i+1))</span><br><span class="line">done</span><br></pre></td></tr></table></figure></li><li>您的任务是编写一个命令，它可以递归地查找文件夹中所有的HTML文件，并将它们压缩成zip文件<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find . -name <span class="string">&quot;*.html&quot;</span> | xargs --delimiter=<span class="string">&quot;\n\b&quot;</span> \</span></span><br><span class="line"><span class="language-bash">zip -r html.zip</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="编辑器-Vim-习题"><a href="#编辑器-Vim-习题" class="headerlink" title="编辑器(Vim)习题"></a>编辑器(Vim)习题</h2><p><em><strong>说明</strong></em>由于我很早之前就配置好了vim, 用了也挺久的, 这里就跳过了. </p><h2 id="数据整理习题"><a href="#数据整理习题" class="headerlink" title="数据整理习题"></a>数据整理习题</h2><ol><li>学习一下这篇简短的 交互式正则表达式教程.<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">You&#x27;ve finished the tutorial!</span><br></pre></td></tr></table></figure></li><li>统计words文件<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /usr/share/dict/words | tr &quot;[:upper:]&quot; &quot;[:lower:]&quot; | grep -E &quot;^([^a]*a)&#123;3&#125;.*$&quot; | grep -v &quot;&#x27;s$&quot; | wc -l</span><br></pre></td></tr></table></figure></li><li>进行原地替换听上去很有诱惑力，例如： <code>sed s/REGEX/SUBSTITUTION/ input.txt &gt; input.txt</code>。但是这并不是一个明智的做法，为什么呢？还是说只有 <code>sed</code>是这样的? 查看 <code>man sed</code> 来完成这个问题<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-i[SUFFIX], --in-place[=SUFFIX]</span><br><span class="line">edit files in place (makes backup if SUFFIX supplied)</span><br></pre></td></tr></table></figure><em><strong>说明</strong></em>在WSL中,有关开关机的习题都无法实验, 所以省略</li></ol><h2 id="命令行环境习题"><a href="#命令行环境习题" class="headerlink" title="命令行环境习题"></a>命令行环境习题</h2><ol><li>我们可以使用类似 <code>ps aux | grep</code> 这样的命令来获取任务的 <code>pid</code> ，然后您可以基于<code>pid</code> 来结束这些进程。但我们其实有更好的方法来做这件事。在终端中执行 <code>sleep 10000</code> 这个任务。然后用 <code>Ctrl-Z</code> 将其切换到后台并使用 <code>bg</code>来继续允许它。现在，使用 <code>pgrep</code> 来查找 <code>pid</code> 并使用 <code>pkill</code> 结束进程而不需要手动输入<code>pid</code><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sleep 10000</span><br><span class="line">// Ctrl-z</span><br><span class="line">bg</span><br><span class="line">pgrep sleep</span><br><span class="line">pkill sleep</span><br></pre></td></tr></table></figure></li><li>如果您希望某个进程结束后再开始另外一个进程， 应该如何实现呢？<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sleep 60 &amp;</span><br><span class="line">pgrep sleep | wait; ls</span><br></pre></td></tr></table></figure></li><li>创建一个 <code>dc</code> 别名，它的功能是当我们错误的将 <code>cd</code> 输入为 <code>dc</code> 时也能正确执行<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias dc=cd</span><br></pre></td></tr></table></figure></li><li>执行 <code>history | awk &#39;&#123;$1=&quot;&quot;;print substr($0,2)&#125;&#39; | sort | uniq -c | sort -n | tail -n 10</code> 来获取您最常用的十条命令，尝试为它们创建别名<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  98 cd project</span><br><span class="line"> 101 cd ..</span><br><span class="line"> 105 git add -A</span><br><span class="line"> 107 l</span><br><span class="line"> 113 cd</span><br><span class="line"> 139 v</span><br><span class="line"> 171 make run</span><br><span class="line"> 198 make</span><br><span class="line"> 299 ..</span><br><span class="line">1828 ls</span><br></pre></td></tr></table></figure></li></ol><h2 id="版本控制-Git-习题"><a href="#版本控制-Git-习题" class="headerlink" title="版本控制(Git)习题"></a>版本控制(Git)习题</h2><ol><li>将版本历史可视化并进行探索<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --all --graph --decorate</span><br></pre></td></tr></table></figure></li><li>是谁最后修改了 README.md文件<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log README.md</span><br></pre></td></tr></table></figure></li><li>最后一次修改<code>_config.yml</code> 文件中 <code>collections:</code> 行时的提交信息是什么<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git blame _config.yml | grep collections</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ysyx </tag>
            
            <tag> Linux </tag>
            
            <tag> WSL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ysyx-预学习阶段-Linux-WSL安装</title>
      <link href="/2023-03-04-ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-Linux-WSL%E5%AE%89%E8%A3%85/"/>
      <url>/2023-03-04-ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-Linux-WSL%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="ysyx-预学习阶段-Linux-WSL安装"><a href="#ysyx-预学习阶段-Linux-WSL安装" class="headerlink" title="ysyx-预学习阶段-Linux-WSL安装"></a>ysyx-预学习阶段-Linux-WSL安装</h1><h2 id="代码仓库及相关网页"><a href="#代码仓库及相关网页" class="headerlink" title="代码仓库及相关网页"></a>代码仓库及相关网页</h2><ul><li><a href="https://ysyx.oscc.cc/">ysyx官方网址</a></li></ul><h2 id="一生一芯实验报告目录"><a href="#一生一芯实验报告目录" class="headerlink" title="一生一芯实验报告目录"></a>一生一芯实验报告目录</h2><ul><li><a href="https://sin-kider.github.io/2023/03/04/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-Linux-WSL%E5%AE%89%E8%A3%85/">ysyx-预学习阶段-Linux-WSL安装</a> ✨</li><li><a href="https://sin-kider.github.io/2023/03/04/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-Linux-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/">ysyx-预学习阶段-Linux-基本使用</a></li><li><a href="https://sin-kider.github.io/2023/03/11/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/">ysyx-预学习阶段-C语言学习</a></li><li><a href="https://sin-kider.github.io/2023/03/18/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-verilog%E5%AD%A6%E4%B9%A0-%E6%90%AD%E5%BB%BAverilator%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83">ysyx-预学习阶段-verilog学习-搭建verilator仿真环境</a></li><li><a href="https://sin-kider.github.io/2023/03/23/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-PA1-NEMU">ysyx-预学习阶段-PA1-NEMU</a></li><li><a href="https://sin-kider.github.io/2023/03/25/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-%E5%A6%82%E4%BD%95%E7%A7%91%E5%AD%A6%E5%9C%B0%E6%8F%90%E9%97%AE-%E8%AF%BB%E5%90%8E%E6%84%9F">ysyx-预学习阶段-如何科学地提问-读后感</a></li><li><a href="https://sin-kider.github.io/2023/04/01/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5-%E6%80%BB%E7%BB%93">ysyx-预学习阶段-总结</a></li><li><a href="https://sin-kider.github.io/2023/04/07/ysyx-B%E9%98%B6%E6%AE%B5-%E7%94%A8RTL%E5%AE%9E%E7%8E%B0%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%A4%84%E7%90%86%E5%99%A8-%E7%94%A8Chisel%E5%AE%9E%E7%8E%B0%E5%8D%95%E5%91%A8%E6%9C%9Friscv64%E5%A4%84%E7%90%86%E5%99%A8">ysyx-B阶段-用RTL实现最简单的处理器-用Chisel实现单周期riscv64处理器</a></li><li><a href="https://sin-kider.github.io/2023/04/07/ysyx-B%E9%98%B6%E6%AE%B5-%E6%94%AF%E6%8C%81RV64IM%E7%9A%84NEMU-%E7%94%A8NEMU%E8%BF%90%E8%A1%8Criscv64%E7%9A%84%E7%A8%8B%E5%BA%8F">ysyx-B阶段-支持RV64IM的NEMU-用NEMU运行riscv64的程序</a></li></ul><h2 id="WSL"><a href="#WSL" class="headerlink" title="WSL"></a>WSL</h2><h3 id="我为什么选择WSL"><a href="#我为什么选择WSL" class="headerlink" title="我为什么选择WSL"></a>我为什么选择WSL</h3><p>由于ysyx项目必须使用linux环境, 我必须在<code>实际安装/虚拟机/WSL</code>之中选择一个, 最后我选择了WSL. 主要原因如下</p><ul><li>占用空间小</li><li>消耗资源少</li><li>可以与windows共存</li><li>WSL GUI可应付绝大部分需要图形界面的情况</li><li>常用软件都可以使用<del>可以一边打游戏一边听音乐写代码</del></li></ul><h3 id="安装并启用WSL"><a href="#安装并启用WSL" class="headerlink" title="安装并启用WSL"></a>安装并启用WSL</h3><p>事实上微软的官方教程已经很详细了:<a href="https://learn.microsoft.com/zh-cn/windows/wsl/install">官方链接</a>  </p><ol><li>安装之前请确认你的<code>Windows</code>版本是否为<code>Win10 2004以上的版本(包括Win11)</code>, 若版本不够, 请升级你的<code>Windows</code>或者选择<code>其他的linux环境</code>.</li><li>打开你的控制面板, 依次选择<code>程序-程序和功能-启用或关闭Windows功能</code>, 将你看到的带有<code>虚拟机</code>, <code>Linux</code>, <code>子系统</code>, <code>Hyper</code>等字样的选项勾选上后, 重启你的Windows.</li><li>打开你的cmd命令窗口, 输入命令. <del><em><strong>注意</strong></em>: 可能需要魔法</del><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wsl --install</span></span><br></pre></td></tr></table></figure>待安装成功后, 直接使用<code>wsl</code>命令启动wsl<br><em><strong>注意</strong></em>: WSL默认安装Ubuntu, 如果想要安装其他Linux发行版, 使用命令查看可用的Linux发行版<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wsl -l -o</span></span><br><span class="line">以下是可安装的有效分发的列表。</span><br><span class="line">使用 &#x27;wsl.exe --install &lt;Distro&gt;&#x27; 安装。</span><br><span class="line"></span><br><span class="line">NAME                                   FRIENDLY NAME</span><br><span class="line">Ubuntu                                 Ubuntu</span><br><span class="line">Debian                                 Debian GNU/Linux</span><br><span class="line">kali-linux                             Kali Linux Rolling</span><br><span class="line">Ubuntu-18.04                           Ubuntu 18.04 LTS</span><br><span class="line">Ubuntu-20.04                           Ubuntu 20.04 LTS</span><br><span class="line">Ubuntu-22.04                           Ubuntu 22.04 LTS</span><br><span class="line">OracleLinux_8_5                        Oracle Linux 8.5</span><br><span class="line">OracleLinux_7_9                        Oracle Linux 7.9</span><br><span class="line">SUSE-Linux-Enterprise-Server-15-SP4    SUSE Linux Enterprise Server 15 SP4</span><br><span class="line">openSUSE-Leap-15.4                     openSUSE Leap 15.4</span><br><span class="line">openSUSE-Tumbleweed                    openSUSE Tumbleweed</span><br></pre></td></tr></table></figure>之后使用命令进行安装<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wsl --install -d [发行版名称]</span></span><br></pre></td></tr></table></figure>安装完成后, 同样使用<code>wsl</code>命令启动你的wsl<br><strong>常见错误</strong>: 出现了部分Linux打印的信息但是很快就退出回到了cmd怎么办<br>大概率是<em>内核版本</em>问题, 如何更新请STFW</li></ol><h3 id="迁移WSL"><a href="#迁移WSL" class="headerlink" title="迁移WSL"></a>迁移WSL</h3><p>WSL默认安装位置为C盘且无法更改, <del>很反人类对吧</del>, 不想C盘爆炸只能想办法迁移到其他盘. 下面给出我自己的解决方案.  </p><ol><li>打开cmd输入, 查看你已安装的分发名称, 比如我的分发叫做<code>ubuntu-sin</code><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wsl -l</span></span><br><span class="line">适用于 Linux 的 Windows 子系统分发:</span><br><span class="line">ubuntu-sin (默认)</span><br></pre></td></tr></table></figure></li><li>使用命令<code>wsl --export [分发名称] [导出的备份名称]</code>导出你已安装的分发(已安装的Linux), 例:<br><em><strong>注意</strong></em>: 导出文件名称最好带上文件路径, 比如<code>C:\Users\yourname\Desktop\ubuntu-sin-backup.tar</code>, 否则你就得慢慢找你导出的文件在哪了.  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --export ubuntu-sin ubuntu-sin-backup.tar</span><br></pre></td></tr></table></figure></li><li>找到你想要安装的路径, 例<code>E\:WSL\</code>, 使用命令<code>wsl --import [分发命名] [安装位置] [导入的分发备份]</code>, 例:<br><em><strong>注意</strong></em>: 新的分发名称不能与已拥有的分发名称相同<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wsl --import ubuntu-sin-new <span class="string">&#x27;E\:WSL\&#x27;</span> <span class="string">&#x27;C:\Users\yourname\Desktop\ubuntu-sin-backup.tar&#x27;</span></span></span><br></pre></td></tr></table></figure></li><li>删除旧的分发<code>wsl --unregister [旧的分发名称]</code><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wsl --unregister ubuntu-sin</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ysyx </tag>
            
            <tag> Linux </tag>
            
            <tag> WSL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+Butterfly主题Blog搭建指南</title>
      <link href="/2023-02-06-Hexo-Butterfly%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/"/>
      <url>/2023-02-06-Hexo-Butterfly%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo-Butterfly主题Blog搭建指南"><a href="#Hexo-Butterfly主题Blog搭建指南" class="headerlink" title="Hexo+Butterfly主题Blog搭建指南"></a>Hexo+Butterfly主题Blog搭建指南</h1><p>这篇文章主要是介绍一下<em>Hexo</em>如何搭建，以及如何给Hexo安装<em>Butterfly</em>主题。相关问题会在文章末尾说明。<br>这边先说明一下我使用的平台：  </p><ul><li>OS:Linux Mint 21.1 x86_64</li><li>Kernel: 5.15.0-58-generic<br>在其他平台没有尝试过，遇到问题需要您自行寻找解决办法。</li></ul><h2 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h2><p>首先你需要安装<a href="https://github.com/nodesource/distributions">nodejs</a>，最新版（v19）即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://deb.nodesource.com/setup_19.x | sudo -E bash - &amp;&amp;\</span><br><span class="line">sudo apt-get install -y nodejs</span><br></pre></td></tr></table></figure><p>若报错，请检查curl是否安装，网络是否正常，必要时请使用梯子。<br>安装后检查npm与node版本，若出现版本号表明安装成功，具体如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">npm -v</span></span><br><span class="line">9.4.1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">node -v</span></span><br><span class="line">v19.6.0</span><br></pre></td></tr></table></figure><p>接下来是安装<a href="https://hexo.io/">Hexo</a>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>若提示权限不足请在npm前面加上sudo提权。安装后使用命令<code>hexo -v</code>检查是否安装成功，出现如下提示代表安装正确。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hexo -v</span></span><br><span class="line">os: linux 5.15.0-58-generic Linux Mint 21.1 (Vera)</span><br><span class="line">node: 19.6.0</span><br><span class="line">v8: 10.8.168.25-node.11</span><br><span class="line">uv: 1.44.2</span><br><span class="line">zlib: 1.2.13</span><br><span class="line">brotli: 1.0.9</span><br><span class="line">ares: 1.18.1</span><br><span class="line">modules: 111</span><br><span class="line">nghttp2: 1.51.0</span><br><span class="line">napi: 8</span><br><span class="line">llhttp: 8.1.0</span><br><span class="line">uvwasi: 0.0.15</span><br><span class="line">acorn: 8.8.2</span><br><span class="line">simdutf: 3.1.0</span><br><span class="line">undici: 5.16.0</span><br><span class="line">openssl: 3.0.7+quic</span><br><span class="line">cldr: 42.0</span><br><span class="line">icu: 72.1</span><br><span class="line">tz: 2022g</span><br><span class="line">unicode: 15.0</span><br><span class="line">ngtcp2: 0.8.1</span><br><span class="line">nghttp3: 0.7.0</span><br></pre></td></tr></table></figure><h2 id="初始化Hexo"><a href="#初始化Hexo" class="headerlink" title="初始化Hexo"></a>初始化Hexo</h2><p>使用命令<code>hexo init &lt;项目名称&gt;</code>初始化项目，例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init myblog</span><br></pre></td></tr></table></figure><p>初始化时报错大概率是网络问题，解决方法同样是梯子。成功后在当前文件夹会生成名为<code>myblog</code>的文件夹，使用<code>cd myblog</code>后进入文件夹，现在你的hexo已经可以使用了。下面列举出hexo的常用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo cl 清除已编译文件</span><br><span class="line">hexo g  编译项目</span><br><span class="line">hexo s  启动项目</span><br><span class="line">hexo -h 输出帮助信息</span><br><span class="line">hexo -v 输出版本信息</span><br></pre></td></tr></table></figure><p>你现在可以使用<code>hexo s</code>来启动默认的Hexo blog，打开浏览器访问<code>https://127.0.0.1:4000/</code>就可以看见生成的blog了</p><h2 id="安装Butterfly主题"><a href="#安装Butterfly主题" class="headerlink" title="安装Butterfly主题"></a>安装Butterfly主题</h2><ol><li>在hexo项目目录下使用命令<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-theme-butterfly</span><br></pre></td></tr></table></figure></li><li>修改站点配置文件<code>_config.yml</code>，把主题改为<code>butterfly</code><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: butterfly</span><br></pre></td></tr></table></figure></li><li>重新运行你的<code>hexo</code><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo cl &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023-02-03-hello/"/>
      <url>/2023-02-03-hello/</url>
      
        <content type="html"><![CDATA[<h1 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello, world!"></a>Hello, world!</h1><p><em><strong>初次搭建HEXO</strong></em></p><div class="note default flat"><p>测试</p></div><div class="note primary flat"><p>测试</p></div><div class="note success flat"><p>测试</p></div><div class="note info flat"><p>测试</p></div><div class="note warning flat"><p>测试</p></div><div class="note danger flat"><p>测试</p></div>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
